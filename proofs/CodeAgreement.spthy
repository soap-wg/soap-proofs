theory MessagingOIDC begin

// Function signature and definition of the equational theory E

functions: extract/1, fingerprint/1, fst/1, h/2, pair/2, pk/1, s256/1,
           sign/2, snd/1, true/0, verify/3
equations:
    extract(fingerprint(x)) = x,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true



heuristic: o "./oracle.py"

restriction OnlyOnce:
  "∀ t #x #y. ((OnlyOnce( t ) @ #x) ∧ (OnlyOnce( t ) @ #y)) ⇒ (#x = #y)"
  // safety formula

restriction Equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction Inequality:
  "∀ x #t. (Neq( x, x ) @ #t) ⇒ (⊥)"
  // safety formula



rule (modulo E) Phone:
   [ Fr( ~sim ) ]
  --[ ClaimNumber( $A, $Number ), IsPhoneNumber( $Number ) ]->
   [ !Phone( $A, $Number ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SMSOut[color=#ffffff]:
   [ SMS_Out( $Number, sms ), !Phone( $A, $Number ) ]
  -->
   [ !SMS( $Number, sms ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) AdversarySMSOut[color=#ff6961]:
   [ In( sms ), !Phone( $A, $Number ) ] --> [ !SMS( $Number, sms ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SMSIn[color=#ffffff]:
   [ !SMS( $Number, sms ) ] --> [ SMS_In( $Number, sms ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SMSLeak[color=#ff6961]:
   [ !SMS( $Number, sms ) ]
  --[ SMSLeak( ), SomeCompromise( ) ]->
   [ Out( sms ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Domain:
   [ ] --> [ !Domain( $Domain ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) DomainCompromise:
   [ !Domain( $Domain ) ]
  --[ CompromisedDomain( $Domain ), SomeCompromise( ) ]->
   [ !DomainCompromise( $Domain ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSClientOut[color=#ffffff]:
   [ TLSClient_Out( method, ~sess, $Domain, msg ), !Domain( $Domain ) ]
  -->
   [ !TLSClient( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSAdversaryClientOut[color=#ff6961]:
   [ In( method ), In( ~sess ), In( msg ), !Domain( $Domain ) ]
  -->
   [ !TLSClient( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSServerOut[color=#ffffff]:
   [ TLSServer_Out( method, ~sess, $Domain, msg ), !Domain( $Domain ) ]
  -->
   [ !TLSServer( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSAdversaryServerOut[color=#ff6961]:
   [ In( method ), In( ~sess ), In( msg ), !DomainCompromise( $Domain ) ]
  -->
   [ !TLSServer( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSClientToServer[color=#ffffff]:
   [ !TLSClient( method, ~sess, $Domain, msg ) ]
  -->
   [ TLSServer_In( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSClientToAdversaryServer[color=#ff6961]:
   [ !TLSClient( method, ~sess, $Domain, msg ), !DomainCompromise( $Domain )
   ]
  -->
   [ Out( msg ), Out( ~sess ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSServerToClient[color=#ffffff]:
   [ !TLSServer( method, ~sess, $Domain, msg ) ]
  -->
   [ TLSClient_In( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSServerToAdversaryClient[color=#ff6961]:
   [
   In( ~adversarySess ), !TLSServer( method, ~adversarySess, $Domain, msg )
   ]
  -->
   [ Out( msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPSetup:
   [ !Domain( $IdP ), Fr( ~idpSk ) ]
  --[ ClaimIdPKey( $IdP, ~idpSk ) ]->
   [ !IdP( $IdP ), !IdPLtk( $IdP, ~idpSk ), Out( pk(~idpSk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPCompromise[color=#ff6961]:
   [ !IdPLtk( $IdP, idpSk ) ]
  --[ CompromisedIdP( $IdP ), SomeCompromise( ) ]->
   [ !IdPCompromise( $IdP ), Out( idpSk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPKeyRequest[color=#9ad5d8]:
   [ !IdP( $IdP ), Fr( ~sess ) ]
  -->
   [
   TLSClient_Out( 'GET', ~sess, $IdP, 'pk_req' ),
   St_IdPKeyReq( $IdP, ~sess )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPPkDistribute[color=#9ad5d8]:
   [ TLSServer_In( 'GET', ~sess, $IdP, 'pk_req' ), !IdPLtk( $IdP, idpSk ) ]
  -->
   [ TLSServer_Out( 'GET', ~sess, $IdP, <'idp_pk', pk(idpSk)> ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) IdPKeyObtain[color=#9ad5d8]:
   [
   St_IdPKeyReq( $IdP, ~sess ),
   TLSClient_In( 'GET', ~sess, $IdP, <'idp_pk', idpPk> )
   ]
  -->
   [ !UseIdPKey( $User, $IdP, idpPk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPSignUp:
   [ Fr( ~pw ), !IdP( $IdP ) ]
  --[ Username( $A, $IdP, $Username, ~pw ) ]->
   [ !IdPAccount( $A, $IdP, $Username, ~pw ) ]

  /* has exactly the trivial AC variant */

restriction AccountsUnique:
  "∀ p1 p2 idp u pw1 pw2 #a #b.
    ((Username( p1, idp, u, pw1 ) @ #a) ∧
     (Username( p2, idp, u, pw2 ) @ #b)) ⇒
    (((p1 = p2) ∧ (pw1 = pw2)) ∧ (#a = #b))"
  // safety formula

rule (modulo E) IdPAccountCompromise[color=#ff6961]:
   [ !IdPAccount( $A, $IdP, $Username, ~pw ) ]
  --[ CompromisedAccount( $A, $IdP, $Username ), SomeCompromise( ) ]->
   [ Out( ~pw ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPPublishClient:
   [ Fr( ~sess ), Fr( ~m ), !IdPAccount( $A, $IdP, $Username, ~pw ) ]
  --[ SendIdP( $IdP, $Username, ~m ), Sender( $A ) ]->
   [ TLSClient_Out( 'GET', ~sess, $IdP, <'publish', $Username, ~pw, ~m> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPPublishServer:
   [
   !IdPAccount( p, $IdP, $Username, ~pw ),
   TLSServer_In( 'GET', ~sess, $IdP, <'publish', $Username, ~pw, m> )
   ]
  -->
   [ Out( m ), !Publish( $IdP, $Username, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPPublishCompromised:
   [ !IdPCompromise( $IdP ), In( m ) ]
  -->
   [ !Publish( $IdP, $Username, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPRead:
   [ !Publish( $IdP, $Username, m ) ]
  --[ ReceiveIdP( $IdP, $Username, m ) ]->
   [ ]

  /* has exactly the trivial AC variant */

lemma PublishExecutability:
  exists-trace
  "∃ user idp m #t.
    (ReceiveIdP( idp, user, m ) @ #t) ∧ (¬(∃ #x. SomeCompromise( ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"∃ user idp m #t.
  (ReceiveIdP( idp, user, m ) @ #t) ∧ ∀ #x. (SomeCompromise( ) @ #x) ⇒ ⊥"
*/
by sorry

lemma IdPChannelSenderInvarianceAgreement:
  all-traces
  "∀ user idp m #t.
    (ReceiveIdP( idp, user, m ) @ #t) ⇒
    ((((∃ #x. SendIdP( idp, user, m ) @ #x) ∨
       (∃ #x. CompromisedIdP( idp ) @ #x)) ∨
      (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
     (∃ p #x. CompromisedAccount( p, idp, user ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ user idp m #t.
  (ReceiveIdP( idp, user, m ) @ #t)
 ∧
  (∀ #x. (SendIdP( idp, user, m ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedIdP( idp ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ p #x. (CompromisedAccount( p, idp, user ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma IdPChannelSenderInvarianceCorrespondence:
  all-traces
  "∀ idp user m1 m2 s1 s2 #t1 #t2.
    ((((SendIdP( idp, user, m1 ) @ #t1) ∧ (Sender( s1 ) @ #t1)) ∧
      (SendIdP( idp, user, m2 ) @ #t2)) ∧
     (Sender( s2 ) @ #t2)) ⇒
    ((((s1 = s2) ∨ (∃ #x. CompromisedIdP( idp ) @ #x)) ∨
      (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
     (∃ p #x. CompromisedAccount( p, idp, user ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ idp user m1 m2 s1 s2 #t1 #t2.
  (SendIdP( idp, user, m1 ) @ #t1) ∧
  (Sender( s1 ) @ #t1) ∧
  (SendIdP( idp, user, m2 ) @ #t2) ∧
  (Sender( s2 ) @ #t2)
 ∧
  (¬(s1 = s2)) ∧
  (∀ #x. (CompromisedIdP( idp ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ p #x. (CompromisedAccount( p, idp, user ) @ #x) ⇒ ⊥)"
*/
by sorry

rule (modulo E) KeyServer:
   [ !Domain( $Domain ) ]
  --[ OnlyOnce( 'key_server' ), IsKeyServer( $Domain ) ]->
   [ !KeyServer( $Domain ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) E2EEOut[color=#ffffff]:
   [ E2EE_Out( pkSender, pkReceiver, msg ) ]
  -->
   [ !E2EE( pkSender, pkReceiver, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) E2EEAdversaryOut[color=#ff6961]:
   [ In( skSender ), In( pkReceiver ), In( msg ) ]
  -->
   [ !E2EE( pk(skSender), pkReceiver, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) E2EEIn[color=#ffffff]:
   [ !E2EE( pkSender, pkReceiver, msg ) ]
  -->
   [ E2EE_In( pkSender, pkReceiver, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) E2EEAdversaryIn[color=#ff6961]:
   [ In( skReceiver ), !E2EE( pkSender, pk(skReceiver), msg ) ]
  -->
   [ Out( msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingRegister[color=#fdfd96]:
   [ Fr( ~sk ), Fr( ~sess ), !Phone( $A, $Number ), !KeyServer( $KeyServer )
   ]
  --[ IsMessagingKey( ~sk ) ]->
   [
   TLSClient_Out( 'GET', ~sess, $KeyServer,
                  <'msg_signup_req', $Number, pk(~sk)>
   ),
   Out( pk(~sk) ), St_MessagingReg_App( $A, $Number, ~sess, ~sk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingChallenge[color=#fdfd96]:
   [
   Fr( ~challenge ), !KeyServer( $Server ),
   TLSServer_In( 'GET', ~sess, $Server, <'msg_signup_req', $Number, ltk> )
   ]
  --[ IsOTP( ~challenge ) ]->
   [
   SMS_Out( $Number, ~challenge ),
   St_SigReg_Server( ~sess, $Number, ltk, ~challenge )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingRespond[color=#fdfd96]:
   [
   !KeyServer( $Server ), St_MessagingReg_App( $A, $Number, ~sess, sk ),
   SMS_In( $Number, challenge )
   ]
  --[ MustBeOTP( challenge ) ]->
   [
   TLSClient_Out( 'GET', ~sess, $Server, <'otp_respond', challenge> ),
   St_MessagingReg_AppWait( $A, $Number, ~sess, sk )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) MessagingAck[color=#fdfd96]:
   [
   !KeyServer( $Server ),
   St_SigReg_Server( ~sess, $Number, ltk, challenge ),
   TLSServer_In( 'GET', ~sess, $Server, <'otp_respond', challenge> )
   ]
  --[ MessagingKeyServer( $Number, ltk ) ]->
   [
   !MessagingLtkServer( $Number, ltk ),
   TLSServer_Out( 'GET', ~sess, $Server, 'msg_signup_ack' )
   ]

  // loop breakers: [1,2]
  /* has exactly the trivial AC variant */

restriction KeysUnique:
  "∀ phone ltk1 ltk2 #a #b.
    ((MessagingKeyServer( phone, ltk1 ) @ #a) ∧
     (MessagingKeyServer( phone, ltk2 ) @ #b)) ⇒
    ((#a = #b) ∧ (ltk1 = ltk2))"
  // safety formula

rule (modulo E) MessagingFin[color=#fdfd96]:
   [
   !KeyServer( $Server ), St_MessagingReg_AppWait( $A, $Number, ~sess, sk ),
   TLSClient_In( 'GET', ~sess, $Server, 'msg_signup_ack' )
   ]
  --[ ClaimMessagingKey( $A, $Number, sk ) ]->
   [ !MessagingLtkUser( $A, $Number, sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingCompromise[color=#ff6961]:
   [ !MessagingLtkUser( $A, $Number, ~sk ) ]
  --[ CompromisedMessaging( $A, pk(~sk) ), SomeCompromise( ) ]->
   [ Out( ~sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingKeyRequest[color=#9ad5d8]:
   [
   !MessagingLtkServer( $Number, ltk ), !KeyServer( $Server ),
   TLSServer_In( 'GET', ~sess, $Server, <'msg_key_req', $Number> )
   ]
  --[ MustBeMessagingKey( ltk ) ]->
   [ TLSServer_Out( 'GET', ~sess, $Server, <'msg_key_resp', $Number, ltk> )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) ObtainKey[color=#9ad5d8]:
   [ Fr( ~sess ), !KeyServer( $Server ) ]
  -->
   [
   TLSClient_Out( 'GET', ~sess, $Server, <'msg_key_req', $Phone> ),
   St_KeyReq( $A, $Phone, ~sess )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ObtainKeyFin[color=#9ad5d8]:
   [
   !KeyServer( $Server ), St_KeyReq( $A, $Phone, ~sess ),
   TLSClient_In( 'GET', ~sess, $Server, <'msg_key_resp', $Phone, ltk> )
   ]
  --[ GotMessagingKey( $Phone, ltk ) ]->
   [ !UseMessagingKeyFor( $A, $Phone, ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SendInterface:
   [ Fr( ~m ) ] --> [ SendAsTo( $A, $Phone, ~m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingSend:
   [
   SendAsTo( $A, $PeerPhone, m ), !MessagingLtkUser( $A, $MyPhone, ~sk ),
   !UseMessagingKeyFor( $A, $PeerPhone, ltk )
   ]
  --[
  SendMessaging( pk(~sk), ltk, m ), Sender( $A ),
  SendTo( $PeerPhone, 'messaging', m )
  ]->
   [ E2EE_Out( pk(~sk), ltk, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingReceive:
   [
   !MessagingLtkUser( $A, $MyPhone, ~skr ),
   !UseMessagingKeyFor( $A, $PeerPhone, pkPeer ),
   E2EE_In( pkPeer, pk(~skr), m )
   ]
  --[ ReceiveMessaging( pkPeer, pk(~skr), m ) ]->
   [ ]

  /* has exactly the trivial AC variant */

lemma MessagingExecutability:
  exists-trace
  "∃ senderPhone myPhone m #t.
    (ReceiveMessaging( senderPhone, myPhone, m ) @ #t) ∧
    (¬(∃ #x. SomeCompromise( ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"∃ senderPhone myPhone m #t.
  (ReceiveMessaging( senderPhone, myPhone, m ) @ #t)
 ∧
  ∀ #x. (SomeCompromise( ) @ #x) ⇒ ⊥"
*/
by sorry

predicate: KeyServerCompromise( )<=>∃ d #x #y. (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y)

lemma MessagingSecrecy:
  all-traces
  "∀ receiverKey m #t.
    (SendTo( receiverKey, 'messaging', m ) @ #t) ⇒
    ((((¬(∃ #x. K( m ) @ #x)) ∨
       (∃ d #x #y. (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y))) ∨
      (∃ #x. SMSLeak( ) @ #x)) ∨
     (∃ r #x. CompromisedMessaging( r, receiverKey ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ receiverKey m #t.
  (SendTo( receiverKey, 'messaging', m ) @ #t)
 ∧
  (∃ #x. (K( m ) @ #x)) ∧
  (∀ d #x #y.
    (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y) ⇒ ⊥) ∧
  (∀ #x. (SMSLeak( ) @ #x) ⇒ ⊥) ∧
  (∀ r #x. (CompromisedMessaging( r, receiverKey ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma MessagingSenderInvarianceAgreement:
  all-traces
  "∀ senderKey myKey m #t.
    (ReceiveMessaging( senderKey, myKey, m ) @ #t) ⇒
    ((((∃ #x. SendMessaging( senderKey, myKey, m ) @ #x) ∨
       (∃ d #x #y. (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y))) ∨
      (∃ #x. SMSLeak( ) @ #x)) ∨
     (∃ s #x. CompromisedMessaging( s, senderKey ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ senderKey myKey m #t.
  (ReceiveMessaging( senderKey, myKey, m ) @ #t)
 ∧
  (∀ #x. (SendMessaging( senderKey, myKey, m ) @ #x) ⇒ ⊥) ∧
  (∀ d #x #y.
    (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y) ⇒ ⊥) ∧
  (∀ #x. (SMSLeak( ) @ #x) ⇒ ⊥) ∧
  (∀ s #x. (CompromisedMessaging( s, senderKey ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma MessagingSenderInvarianceCorresondence:
  all-traces
  "∀ senderKey receiverKey1 receiverKey2 m1 m2 sender1 sender2 #t1 #t2.
    ((((SendMessaging( senderKey, receiverKey1, m1 ) @ #t1) ∧
       (Sender( sender1 ) @ #t1)) ∧
      (SendMessaging( senderKey, receiverKey2, m2 ) @ #t2)) ∧
     (Sender( sender2 ) @ #t2)) ⇒
    ((((sender1 = sender2) ∨
       (∃ d #x #y. (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y))) ∨
      (∃ #x. SMSLeak( ) @ #x)) ∨
     (∃ s #x. CompromisedMessaging( s, senderKey ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ senderKey receiverKey1 receiverKey2 m1 m2 sender1 sender2 #t1 #t2.
  (SendMessaging( senderKey, receiverKey1, m1 ) @ #t1) ∧
  (Sender( sender1 ) @ #t1) ∧
  (SendMessaging( senderKey, receiverKey2, m2 ) @ #t2) ∧
  (Sender( sender2 ) @ #t2)
 ∧
  (¬(sender1 = sender2)) ∧
  (∀ d #x #y.
    (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y) ⇒ ⊥) ∧
  (∀ #x. (SMSLeak( ) @ #x) ⇒ ⊥) ∧
  (∀ s #x. (CompromisedMessaging( s, senderKey ) @ #x) ⇒ ⊥)"
*/
by sorry

rule (modulo E) Client:
   [ ] --> [ !Client( $App ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingApp:
   [ !Client( $App ) ]
  --[ IsMessagingApp( $App ), OnlyOnce( 'messaging_app_client' ) ]->
   [ !MessagingApp( $App ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) RedirectURL:
   [ !IdP( $IdP ), !Client( $App ), !Domain( $RedirectURL ) ]
  --[ IsRedirectURL( $IdP, $App, $RedirectURL ) ]->
   [ !RedirectURL( $IdP, $App, $RedirectURL ) ]

  /* has exactly the trivial AC variant */

restriction UniqueRedirectURLs:
  "∀ idp1 idp2 app1 app2 url #t1 #t2 #t3.
    (((IsMessagingApp( app1 ) @ #t1) ∧
      (IsRedirectURL( idp1, app1, url ) @ #t2)) ∧
     (IsRedirectURL( idp2, app2, url ) @ #t3)) ⇒
    ((idp1 = idp2) ∧ (app1 = app2))"
  // safety formula

rule (modulo E) InitSessionStore:
   [ ]
  --[ OnlyOnce( <'init_session_store', $User> ) ]->
   [ SessionStore( $User, 'null', 'null' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ClearSessionStore:
   [ SessionStore( $User, x, y ) ]
  -->
   [ SessionStore( $User, 'null', 'null' ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) LinkClick[color=#ff6961]:
   [ Fr( ~sess ), In( m ), !Domain( $Domain ) ]
  --[
  GenBrowserSession( $Prover, $Domain, ~sess ), AdversaryLinkClick( ),
  SomeCompromise( )
  ]->
   [
   TLSClient_Out( 'GET', ~sess, $Domain, m ),
   Browser( $Prover, $Domain, ~sess )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OIDCAppLaunchBrowser[color=#b4d9ef]:
   [
   !IdP( $IdP ), !MessagingApp( $App ),
   !RedirectURL( $IdP, $App, $RedirectURL ),
   !MessagingLtkUser( $Prover, $ProverPhone, skProver ),
   !UseMessagingKeyFor( $Prover, $VerifierPhone, pkVerifier ),
   SessionStore( $Prover, drop1, drop2 ), Fr( salt ), Fr( nonce ),
   Fr( code_verifier ), Fr( ~sess )
   ]
  --[
  GenNonce( nonce ), GenBrowserSession( $Prover, $IdP, ~sess ),
  GenerateCodeVerifierFor( code_verifier, $IdP ),
  IsCodeChallenge( s256(code_verifier) ), SOAPStart( $Prover, nonce ),
  SOAPMessaging( $Prover, nonce, pkVerifier, pk(skProver) )
  ]->
   [
   TLSClient_Out( 'GET', ~sess, $IdP,
                  <'oidc_req', $App, h(fingerprint(<pk(skProver), pkVerifier>), salt), 
                   nonce, s256(code_verifier), $RedirectURL>
   ),
   Out( <h(fingerprint(<pk(skProver), pkVerifier>), salt), nonce, 
         s256(code_verifier)>
   ),
   SessionStore( $Prover, nonce,
                 <$IdP, $VerifierPhone, h(fingerprint(<pk(skProver), pkVerifier>), salt), 
                  salt, code_verifier>
   ),
   Browser( $Prover, $IdP, ~sess )
   ]

  // loop breaker: [5]
  /* has exactly the trivial AC variant */

rule (modulo E) OIDCIdPInit[color=#b4d9ef]:
   [
   !IdP( $IdP ), !RedirectURL( $IdP, $Client, $RedirectURL ),
   TLSServer_In( 'GET', ~sess, $IdP,
                 <'oidc_req', $Client, hash, nonce, code_challenge, $RedirectURL>
   )
   ]
  --[ MustBeNonce( nonce ) ]->
   [
   TLSServer_Out( 'GET', ~sess, $IdP, 'auth_req' ),
   St_OIDCServer_Auth( $IdP, $Client, $RedirectURL, ~sess, hash, nonce,
                       code_challenge
   )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) OIDCAppLogin[color=#b4d9ef]:
   [
   Browser( $Prover, $IdP, ~sess ), !IdP( $IdP ),
   TLSClient_In( 'GET', ~sess, $IdP, 'auth_req' ),
   !IdPAccount( $Prover, $IdP, $Username, ~pw )
   ]
  --[ UseBrowserSession( $Prover, $IdP, ~sess ) ]->
   [
   TLSClient_Out( 'GET', ~sess, $IdP, <'login', $Username, ~pw> ),
   Browser( $Prover, $IdP, ~sess )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

lemma PasswordsConfidential [reuse]:
  all-traces
  "∀ user idp username pw #t1 #t2.
    ((Username( user, idp, username, pw ) @ #t1) ∧ (!KU( pw ) @ #t2)) ⇒
    ((∃ #x. CompromisedDomain( idp ) @ #x) ∨
     (∃ someone #x. CompromisedAccount( someone, idp, username ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ user idp username pw #t1 #t2.
  (Username( user, idp, username, pw ) @ #t1) ∧ (!KU( pw ) @ #t2)
 ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ someone #x. (CompromisedAccount( someone, idp, username ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma MessagingKeysUnique [reuse]:
  all-traces
  "∀ userA userB phoneA phoneB sk #a #b.
    ((ClaimMessagingKey( userA, phoneA, sk ) @ #a) ∧
     (ClaimMessagingKey( userB, phoneB, sk ) @ #b)) ⇒
    ((((#a = #b) ∧ (userA = userB)) ∧ (phoneA = phoneB)) ∨
     (∃ d #x #y. (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y)))"
/*
guarded formula characterizing all counter-examples:
"∃ userA userB phoneA phoneB sk #a #b.
  (ClaimMessagingKey( userA, phoneA, sk ) @ #a) ∧
  (ClaimMessagingKey( userB, phoneB, sk ) @ #b)
 ∧
  (((¬(#a = #b)) ∨ (¬(userA = userB)) ∨ (¬(phoneA = phoneB)))) ∧
  (∀ d #x #y. (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y) ⇒ ⊥)"
*/
by sorry

rule (modulo E) OIDCIdPIssueCode[color=#b4d9ef]:
   [
   !IdP( $IdP ), !IdPAccount( $User, $IdP, $Username, pw ), Fr( ~code ),
   Fr( ~sess2 ),
   St_OIDCServer_Auth( $IdP, $Client, $RedirectURL, ~sess, hash, nonce,
                       code_challenge
   ),
   TLSServer_In( 'GET', ~sess, $IdP, <'login', $Username, pw> )
   ]
  --[
  IdPIssueCode( $IdP, $Username, ~code ), IsPW( pw ), IsCode( ~code ),
  MustBeNonce( nonce ), GenCode( $IdP, ~code ),
  SOAPIdP( $User, nonce, $IdP, $Username )
  ]->
   [
   TLSClient_Out( 'GET', ~sess2, $RedirectURL, <'code', ~code, nonce> ),
   St_OIDCIdP_Code( $IdP, $Username, $Client, ~code, hash, nonce,
                    code_challenge
   )
   ]

  // loop breaker: [5]
  /* has exactly the trivial AC variant */

rule (modulo E) OIDCAppCodeRedirect[color=#b4d9ef]:
   [
   !RedirectURL( $IdP, $App, $RedirectURL ), !IdP( $IdP ),
   !MessagingApp( $App ), Fr( ~sessPost ),
   SessionStore( $Prover, nonce,
                 <$IdP, $VerifierPhone, hash, salt, code_verifier>
   ),
   TLSServer_In( 'GET', ~sess, $RedirectURL, <'code', code, nonce> )
   ]
  --[
  AppReceiveCode( $Prover, $IdP, code ), SelfIssued( $Prover, nonce ),
  Neq( nonce, 'null' ), MustBeCode( code )
  ]->
   [
   TLSClient_Out( 'POST', ~sessPost, $IdP,
                  <'token_req', code, code_verifier>
   ),
   St_OIDCApp_CodeReq( $Prover, $IdP, $VerifierPhone, ~sessPost, hash, salt,
                       code
   ),
   SessionStore( $Prover, 'null', 'null' )
   ]

  // loop breaker: [5]
  /* has exactly the trivial AC variant */

rule (modulo E) OIDCIdPTokenIssue[color=#b4d9ef]:
   [
   !IdPLtk( $IdP, idpSk ),
   St_OIDCIdP_Code( $IdP, $Username, $Client, code, hash, nonce,
                    code_challenge
   ),
   TLSServer_In( 'POST', ~sess, $IdP, <'token_req', code, code_verifier> )
   ]
  --[
  Eq( s256(code_verifier), code_challenge ),
  IssueTokenForCode( $IdP, ~sess, code ),
  MustBeToken( <<$IdP, $Client, $Username, nonce, hash>, 
                sign(<$IdP, $Client, $Username, nonce, hash>, idpSk)>
  ),
  UseCode( $IdP, $Client, code ), UseCodeVerifierFor( $IdP, code_verifier )
  ]->
   [
   TLSServer_Out( 'POST', ~sess, $IdP,
                  <'token', <$IdP, $Client, $Username, nonce, hash>, 
                   sign(<$IdP, $Client, $Username, nonce, hash>, idpSk)>
   )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

lemma CodeSecrecy [reuse]:
  all-traces
  "∀ idp client code #t1 #t2 #t3.
    (((UseCode( idp, client, code ) @ #t1) ∧
      (IsMessagingApp( client ) @ #t2)) ∧
     (!KU( code ) @ #t3)) ⇒
    (((∃ #x. (UsedCode( idp, code ) @ #x) ∧ (#x < #t3)) ∨
      (∃ url #x #y.
        (IsRedirectURL( idp, client, url ) @ #x) ∧
        (CompromisedDomain( url ) @ #y))) ∨
     (∃ #x. CompromisedDomain( idp ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ idp client code #t1 #t2 #t3.
  (UseCode( idp, client, code ) @ #t1) ∧
  (IsMessagingApp( client ) @ #t2) ∧
  (!KU( code ) @ #t3)
 ∧
  (∀ #x. (UsedCode( idp, code ) @ #x) ⇒ ¬(#x < #t3)) ∧
  (∀ url #x #y.
    (IsRedirectURL( idp, client, url ) @ #x) ∧
    (CompromisedDomain( url ) @ #y)
   ⇒
    ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma CodeVerifierSecrecy [reuse]:
  all-traces
  "∀ verifier idp #x #y.
    ((UseCodeVerifierFor( idp, verifier ) @ #x) ∧
     (GenerateCodeVerifierFor( verifier, idp ) @ #y)) ⇒
    ((¬(∃ #z. !KU( verifier ) @ #z)) ∨
     (∃ #z. CompromisedDomain( idp ) @ #z))"
/*
guarded formula characterizing all counter-examples:
"∃ verifier idp #x #y.
  (UseCodeVerifierFor( idp, verifier ) @ #x) ∧
  (GenerateCodeVerifierFor( verifier, idp ) @ #y)
 ∧
  (∃ #z. (!KU( verifier ) @ #z)) ∧
  (∀ #z. (CompromisedDomain( idp ) @ #z) ⇒ ⊥)"
*/
by sorry

lemma TokenFormatAndOTPLearning [sources]:
  all-traces
  "((((∀ token #i.
        (MustBeToken( token ) @ #i) ⇒
        (∃ first second user idp client nonce hashed sk.
          ((((token = <first, second>) ∧
             (first = <idp, client, user, nonce, hashed>)) ∧
            ((∃ #h. (!KU( nonce ) @ #h) ∧ (#h < #i)) ∨
             (∃ #h. GenNonce( nonce ) @ #h))) ∧
           ((∃ #h. (!KU( hashed ) @ #h) ∧ (#h < #i)) ∨
            (∃ fp salt. hashed = h(fp, salt)))) ∧
          (second = sign(first, sk)))) ∧
      (∀ nonce #i.
        (MustBeNonce( nonce ) @ #i) ⇒
        ((∃ #h. (!KU( nonce ) @ #h) ∧ (#h < #i)) ∨
         (∃ #h. GenNonce( nonce ) @ #h)))) ∧
     (∀ code #i.
       (MustBeCode( code ) @ #i) ⇒
       ((∃ #h. (!KU( code ) @ #h) ∧ (#h < #i)) ∨
        (∃ #h. IsCode( code ) @ #h)))) ∧
    (∀ chall #i.
      (MustBeOTP( chall ) @ #i) ⇒
      ((∃ #j. (IsOTP( chall ) @ #j) ∧ (#j < #i)) ∨
       (∃ #j. (!KU( chall ) @ #j) ∧ (#j < #i))))) ∧
   (∀ ltk #i.
     (MustBeMessagingKey( ltk ) @ #i) ⇒
     ((∃ sk #j. (IsMessagingKey( sk ) @ #j) ∧ (ltk = pk(sk))) ∨
      (∃ #j. (!KU( ltk ) @ #j) ∧ (#j < #i))))"
/*
guarded formula characterizing all counter-examples:
"((∃ token #i.
    (MustBeToken( token ) @ #i)
   ∧
    ∀ first second user idp client nonce hashed sk.
     (token = <first, second>) ∧
     (first = <idp, client, user, nonce, hashed>) ∧
     (second = sign(first, sk))
    ⇒
     (((∀ #h. (!KU( nonce ) @ #h) ⇒ ¬(#h < #i)) ∧
       (∀ #h. (GenNonce( nonce ) @ #h) ⇒ ⊥)) ∨
      ((∀ #h. (!KU( hashed ) @ #h) ⇒ ¬(#h < #i)) ∧
       (∀ fp salt. (hashed = h(fp, salt)) ⇒ ⊥)))) ∨
  (∃ nonce #i.
    (MustBeNonce( nonce ) @ #i)
   ∧
    (∀ #h. (!KU( nonce ) @ #h) ⇒ ¬(#h < #i)) ∧
    (∀ #h. (GenNonce( nonce ) @ #h) ⇒ ⊥)) ∨
  (∃ code #i.
    (MustBeCode( code ) @ #i)
   ∧
    (∀ #h. (!KU( code ) @ #h) ⇒ ¬(#h < #i)) ∧
    (∀ #h. (IsCode( code ) @ #h) ⇒ ⊥)) ∨
  (∃ chall #i.
    (MustBeOTP( chall ) @ #i)
   ∧
    (∀ #j. (IsOTP( chall ) @ #j) ⇒ ¬(#j < #i)) ∧
    (∀ #j. (!KU( chall ) @ #j) ⇒ ¬(#j < #i))) ∨
  (∃ ltk #i.
    (MustBeMessagingKey( ltk ) @ #i)
   ∧
    (∀ sk #j. (IsMessagingKey( sk ) @ #j) ∧ (ltk = pk(sk)) ⇒ ⊥) ∧
    (∀ #j. (!KU( ltk ) @ #j) ⇒ ¬(#j < #i))))"
*/
by sorry

rule (modulo E) OIDCTokenForward[color=#b4d9ef]:
   [
   !IdP( $IdP ), !MessagingApp( $App ),
   !UseMessagingKeyFor( $Prover, $VerifierPhone, pkVerifier ),
   !UseIdPKey( $Prover, $IdP, pkIdP ),
   !MessagingLtkUser( $Prover, $ProverPhone, skProver ),
   St_OIDCApp_CodeReq( $Prover, $IdP, $VerifierPhone, ~sessPost, hash, salt,
                       code
   ),
   TLSClient_In( 'POST', ~sessPost, $IdP,
                 <'token', <$IdP, $App, $Username, nonce, hash>, signature>
   )
   ]
  --[
  Eq( h(fingerprint(<pk(skProver), pkVerifier>), salt), hash ),
  Eq( verify(signature, <$IdP, $App, $Username, nonce, hash>, pkIdP), true
  ),
  GetTokenForCode( $IdP, ~sessPost, code ),
  Forward( $Prover, <<$IdP, $App, $Username, nonce, hash>, signature> ),
  MustBeToken( <<$IdP, $App, $Username, nonce, hash>, signature> ),
  MustBeCode( code ), UsedCode( $IdP, code )
  ]->
   [
   SendAsTo( $Prover, $VerifierPhone,
             <'fwd_token', <<$IdP, $App, $Username, nonce, hash>, signature>, salt>
   ),
   Out( code )
   ]

  /*
  rule (modulo AC) OIDCTokenForward[color=#b4d9ef]:
     [
     !IdP( $IdP ), !MessagingApp( $App ),
     !UseMessagingKeyFor( $Prover, $VerifierPhone, pkVerifier ),
     !UseIdPKey( $Prover, $IdP, pkIdP ),
     !MessagingLtkUser( $Prover, $ProverPhone, skProver ),
     St_OIDCApp_CodeReq( $Prover, $IdP, $VerifierPhone, ~sessPost, hash, salt,
                         code
     ),
     TLSClient_In( 'POST', ~sessPost, $IdP,
                   <'token', <$IdP, $App, $Username, nonce, hash>, signature>
     )
     ]
    --[
    Eq( h(fingerprint(<pk(skProver), pkVerifier>), salt), hash ),
    Eq( z, true ), GetTokenForCode( $IdP, ~sessPost, code ),
    Forward( $Prover, <<$IdP, $App, $Username, nonce, hash>, signature> ),
    MustBeToken( <<$IdP, $App, $Username, nonce, hash>, signature> ),
    MustBeCode( code ), UsedCode( $IdP, code )
    ]->
     [
     SendAsTo( $Prover, $VerifierPhone,
               <'fwd_token', <<$IdP, $App, $Username, nonce, hash>, signature>, salt>
     ),
     Out( code )
     ]
    variants (modulo AC)
    1. $App  = $App.34
       $IdP  = $IdP.35
       $Username
             = $Username.38
       hash  = hash.42
       nonce = nonce.43
       pkIdP = pkIdP.44
       signature
             = signature.47
       z     = verify(signature.47,
                      <$IdP.35, $App.34, $Username.38, nonce.43, hash.42>, pkIdP.44)
    
    2. $App  = $App.69
       $IdP  = $IdP.70
       $Username
             = $Username.73
       hash  = hash.77
       nonce = nonce.78
       pkIdP = pk(x.136)
       signature
             = sign(<$IdP.70, $App.69, $Username.73, nonce.78, hash.77>, x.136)
       z     = true
  */

lemma CodeAgreement [use_induction, reuse]:
  all-traces
  "∀ idp sess codeClient codeIdP #t1 #t2.
    ((GetTokenForCode( idp, sess, codeClient ) @ #t1) ∧
     (IssueTokenForCode( idp, sess, codeIdP ) @ #t2)) ⇒
    ((codeClient = codeIdP) ∨ (∃ #x. CompromisedDomain( idp ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ idp sess codeClient codeIdP #t1 #t2.
  (GetTokenForCode( idp, sess, codeClient ) @ #t1) ∧
  (IssueTokenForCode( idp, sess, codeIdP ) @ #t2)
 ∧
  (¬(codeClient = codeIdP)) ∧ (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#t2))  ∥ (last(#t1))  ∥ (codeClient = codeIdP)  ∥
         (∃ #x. (CompromisedDomain( $IdP ) @ #x) ∧ ¬(last(#x))) )
    case case_1
    solve( St_OIDCApp_CodeReq( $Prover, $IdP, $VerifierPhone, ~sessPost,
                               h(fingerprint(<pk(skProver), pkVerifier>), salt), salt, codeClient
           ) ▶₅ #t1 )
      case OIDCAppCodeRedirect_case_1
      solve( TLSClient_In( 'POST', ~sessPost, $IdP,
                           <'token', 
                            <$IdP, $App, $Username, nonce, h(fingerprint(<pk(~sk), pkVerifier>), ~n)
                            >, 
                            sign(<$IdP, $App, $Username, nonce, 
                                  h(fingerprint(<pk(~sk), pkVerifier>), ~n)>,
                                 x)
                           >
             ) ▶₆ #t1 )
        case TLSServerToClient_case_1
        solve( (codeClient = ~code)  ∥
               (∃ #x. (CompromisedDomain( $IdP ) @ #x) ∧ ¬(last(#x))) )
          case case_1
          solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                               <'token_req', codeIdP, code_verifier>
                 ) ▶₂ #t2 )
            case TLSClientToServer_case_1
            by contradiction /* from formulas */
          next
            case TLSClientToServer_case_2
            solve( !KU( ~sessPost ) @ #vk.1 )
              case TLSClientToAdversaryServer_case_1
              solve( TLSServer_In( 'GET', ~sessPost, $Domain,
                                   <'oidc_req', $Client.1, hash.1, nonce.2, code_challenge, $RedirectURL.3>
                     ) ▶₂ #vr.70 )
                case TLSClientToServer
                by contradiction /* cyclic */
              qed
            next
              case TLSClientToAdversaryServer_case_2
              by contradiction /* from formulas */
            qed
          qed
        next
          case case_2
          by contradiction /* from formulas */
        qed
      next
        case TLSServerToClient_case_2
        by contradiction /* from formulas */
      qed
    next
      case OIDCAppCodeRedirect_case_2
      solve( TLSClient_In( 'POST', ~sessPost, $IdP,
                           <'token', 
                            <$IdP, $App, $Username, nonce, h(fingerprint(<pk(~sk), pkVerifier>), ~n)
                            >, 
                            sign(<$IdP, $App, $Username, nonce, 
                                  h(fingerprint(<pk(~sk), pkVerifier>), ~n)>,
                                 x)
                           >
             ) ▶₆ #t1 )
        case TLSServerToClient_case_1
        solve( (codeClient = ~code)  ∥
               (∃ #x. (CompromisedDomain( $IdP ) @ #x) ∧ ¬(last(#x))) )
          case case_1
          solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                               <'token_req', codeIdP, code_verifier>
                 ) ▶₂ #t2 )
            case TLSClientToServer_case_1
            by contradiction /* from formulas */
          next
            case TLSClientToServer_case_2
            solve( !KU( ~sessPost ) @ #vk.8 )
              case TLSClientToAdversaryServer_case_1
              solve( TLSServer_In( 'GET', ~sessPost, $Domain,
                                   <'oidc_req', $Client.1, hash.1, nonce.2, code_challenge, $RedirectURL.3>
                     ) ▶₂ #vr.69 )
                case TLSClientToServer
                by contradiction /* cyclic */
              qed
            next
              case TLSClientToAdversaryServer_case_2
              by contradiction /* from formulas */
            qed
          qed
        next
          case case_2
          by contradiction /* from formulas */
        qed
      next
        case TLSServerToClient_case_2
        by contradiction /* from formulas */
      qed
    next
      case OIDCAppCodeRedirect_case_3
      solve( TLSClient_In( 'POST', ~sessPost, $IdP,
                           <'token', 
                            <$IdP, $App, $Username, nonce, h(fingerprint(<pk(~sk), pkVerifier>), ~n)
                            >, 
                            sign(<$IdP, $App, $Username, nonce, 
                                  h(fingerprint(<pk(~sk), pkVerifier>), ~n)>,
                                 x)
                           >
             ) ▶₆ #t1 )
        case TLSServerToClient_case_1
        solve( (codeClient = ~code)  ∥
               (∃ #x. (CompromisedDomain( $IdP ) @ #x) ∧ ¬(last(#x))) )
          case case_1
          solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                               <'token_req', codeIdP, code_verifier>
                 ) ▶₂ #t2 )
            case TLSClientToServer_case_1
            by contradiction /* from formulas */
          next
            case TLSClientToServer_case_2
            solve( !KU( ~sessPost ) @ #vk.4 )
              case TLSClientToAdversaryServer_case_1
              solve( TLSServer_In( 'GET', ~sessPost, $Domain,
                                   <'oidc_req', $Client.1, hash.1, nonce.2, code_challenge, $RedirectURL.3>
                     ) ▶₂ #vr.70 )
                case TLSClientToServer
                by contradiction /* cyclic */
              qed
            next
              case TLSClientToAdversaryServer_case_2
              by contradiction /* from formulas */
            qed
          qed
        next
          case case_2
          by contradiction /* from formulas */
        qed
      next
        case TLSServerToClient_case_2
        by contradiction /* from formulas */
      qed
    next
      case OIDCAppCodeRedirect_case_4
      solve( TLSClient_In( 'POST', ~sessPost, $IdP,
                           <'token', 
                            <$IdP, $App, $Username, nonce, h(fingerprint(<pk(~sk), pkVerifier>), ~n)
                            >, 
                            sign(<$IdP, $App, $Username, nonce, 
                                  h(fingerprint(<pk(~sk), pkVerifier>), ~n)>,
                                 x)
                           >
             ) ▶₆ #t1 )
        case TLSServerToClient_case_1
        solve( (codeClient = ~code)  ∥
               (∃ #x. (CompromisedDomain( $IdP ) @ #x) ∧ ¬(last(#x))) )
          case case_1
          solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                               <'token_req', codeIdP, code_verifier>
                 ) ▶₂ #t2 )
            case TLSClientToServer_case_1
            by contradiction /* from formulas */
          next
            case TLSClientToServer_case_2
            solve( !KU( ~sessPost ) @ #vk.10 )
              case TLSClientToAdversaryServer_case_1
              solve( TLSServer_In( 'GET', ~sessPost, $Domain,
                                   <'oidc_req', $Client.1, hash.1, nonce.2, code_challenge, $RedirectURL.3>
                     ) ▶₂ #vr.69 )
                case TLSClientToServer
                by contradiction /* cyclic */
              qed
            next
              case TLSClientToAdversaryServer_case_2
              by contradiction /* from formulas */
            qed
          qed
        next
          case case_2
          by contradiction /* from formulas */
        qed
      next
        case TLSServerToClient_case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_2
    solve( St_OIDCApp_CodeReq( $Prover, $IdP, $VerifierPhone, ~sessPost,
                               h(fingerprint(<pk(skProver), pkVerifier>), salt), salt, codeClient
           ) ▶₅ #t1 )
      case OIDCAppCodeRedirect_case_1
      solve( TLSClient_In( 'POST', ~sessPost, $IdP,
                           <'token', 
                            <$IdP, $App, $Username, nonce, h(fingerprint(<pk(~sk), pkVerifier>), ~n)
                            >, 
                            sign(<$IdP, $App, $Username, nonce, 
                                  h(fingerprint(<pk(~sk), pkVerifier>), ~n)>,
                                 x)
                           >
             ) ▶₆ #t1 )
        case TLSServerToClient_case_1
        solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                             <'token_req', codeIdP, code_verifier>
               ) ▶₂ #t2 )
          case TLSClientToServer_case_1
          by contradiction /* from formulas */
        next
          case TLSClientToServer_case_2
          solve( !KU( ~sessPost ) @ #vk.1 )
            case TLSClientToAdversaryServer_case_1
            solve( TLSServer_In( 'GET', ~sessPost, $Domain,
                                 <'oidc_req', $Client.1, hash.1, nonce.2, code_challenge, $RedirectURL.3>
                   ) ▶₂ #vr.70 )
              case TLSClientToServer
              by contradiction /* cyclic */
            qed
          next
            case TLSClientToAdversaryServer_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case TLSServerToClient_case_2
        by contradiction /* from formulas */
      qed
    next
      case OIDCAppCodeRedirect_case_2
      solve( TLSClient_In( 'POST', ~sessPost, $IdP,
                           <'token', 
                            <$IdP, $App, $Username, nonce, h(fingerprint(<pk(~sk), pkVerifier>), ~n)
                            >, 
                            sign(<$IdP, $App, $Username, nonce, 
                                  h(fingerprint(<pk(~sk), pkVerifier>), ~n)>,
                                 x)
                           >
             ) ▶₆ #t1 )
        case TLSServerToClient_case_1
        solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                             <'token_req', codeIdP, code_verifier>
               ) ▶₂ #t2 )
          case TLSClientToServer_case_1
          by contradiction /* from formulas */
        next
          case TLSClientToServer_case_2
          solve( !KU( ~sessPost ) @ #vk.8 )
            case TLSClientToAdversaryServer_case_1
            solve( TLSServer_In( 'GET', ~sessPost, $Domain,
                                 <'oidc_req', $Client.1, hash.1, nonce.2, code_challenge, $RedirectURL.3>
                   ) ▶₂ #vr.69 )
              case TLSClientToServer
              by contradiction /* cyclic */
            qed
          next
            case TLSClientToAdversaryServer_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case TLSServerToClient_case_2
        by contradiction /* from formulas */
      qed
    next
      case OIDCAppCodeRedirect_case_3
      solve( TLSClient_In( 'POST', ~sessPost, $IdP,
                           <'token', 
                            <$IdP, $App, $Username, nonce, h(fingerprint(<pk(~sk), pkVerifier>), ~n)
                            >, 
                            sign(<$IdP, $App, $Username, nonce, 
                                  h(fingerprint(<pk(~sk), pkVerifier>), ~n)>,
                                 x)
                           >
             ) ▶₆ #t1 )
        case TLSServerToClient_case_1
        solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                             <'token_req', codeIdP, code_verifier>
               ) ▶₂ #t2 )
          case TLSClientToServer_case_1
          by contradiction /* from formulas */
        next
          case TLSClientToServer_case_2
          solve( !KU( ~sessPost ) @ #vk.4 )
            case TLSClientToAdversaryServer_case_1
            solve( TLSServer_In( 'GET', ~sessPost, $Domain,
                                 <'oidc_req', $Client.1, hash.1, nonce.2, code_challenge, $RedirectURL.3>
                   ) ▶₂ #vr.70 )
              case TLSClientToServer
              by contradiction /* cyclic */
            qed
          next
            case TLSClientToAdversaryServer_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case TLSServerToClient_case_2
        by contradiction /* from formulas */
      qed
    next
      case OIDCAppCodeRedirect_case_4
      solve( TLSClient_In( 'POST', ~sessPost, $IdP,
                           <'token', 
                            <$IdP, $App, $Username, nonce, h(fingerprint(<pk(~sk), pkVerifier>), ~n)
                            >, 
                            sign(<$IdP, $App, $Username, nonce, 
                                  h(fingerprint(<pk(~sk), pkVerifier>), ~n)>,
                                 x)
                           >
             ) ▶₆ #t1 )
        case TLSServerToClient_case_1
        solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                             <'token_req', codeIdP, code_verifier>
               ) ▶₂ #t2 )
          case TLSClientToServer_case_1
          by contradiction /* from formulas */
        next
          case TLSClientToServer_case_2
          solve( !KU( ~sessPost ) @ #vk.10 )
            case TLSClientToAdversaryServer_case_1
            solve( TLSServer_In( 'GET', ~sessPost, $Domain,
                                 <'oidc_req', $Client.1, hash.1, nonce.2, code_challenge, $RedirectURL.3>
                   ) ▶₂ #vr.69 )
              case TLSClientToServer
              by contradiction /* cyclic */
            qed
          next
            case TLSClientToAdversaryServer_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case TLSServerToClient_case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_3
    by contradiction /* from formulas */
  next
    case case_4
    by contradiction /* from formulas */
  qed
qed

lemma CodeIsSingleUse [reuse]:
  all-traces
  "∀ idp code #a #b.
    ((UsedCode( idp, code ) @ #a) ∧ (UsedCode( idp, code ) @ #b)) ⇒
    (((#a = #b) ∨ (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
     (∃ app url #x #y.
       (IsRedirectURL( idp, app, url ) @ #x) ∧
       (CompromisedDomain( url ) @ #y)))"
/*
guarded formula characterizing all counter-examples:
"∃ idp code #a #b.
  (UsedCode( idp, code ) @ #a) ∧ (UsedCode( idp, code ) @ #b)
 ∧
  (¬(#a = #b)) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ app url #x #y.
    (IsRedirectURL( idp, app, url ) @ #x) ∧ (CompromisedDomain( url ) @ #y)
   ⇒
    ⊥)"
*/
by sorry

rule (modulo E) OIDCTokenReceive[color=#b4d9ef]:
   [
   !MessagingLtkUser( $Verifier, $VerifierPhone, skVerifier ),
   !UseMessagingKeyFor( $Verifier, $ProverPhone, pkProver ),
   !MessagingApp( $App ), !UseIdPKey( $Verifier, $IdP, pkIdP ),
   E2EE_In( pkProver, pk(skVerifier),
            <'fwd_token', <<$IdP, $App, $Username, nonce, hash>, signature>, salt>
   )
   ]
  --[
  Eq( h(fingerprint(<pkProver, pk(skVerifier)>), salt), hash ),
  Eq( verify(signature, <$IdP, $App, $Username, nonce, hash>, pkIdP), true
  ),
  DidNotIssueSelf( $Verifier, nonce ), ReceivingKey( pk(skVerifier) ),
  AssociateAs( $Verifier, pkProver, $IdP, $Username )
  ]->
   [ ]

  /*
  rule (modulo AC) OIDCTokenReceive[color=#b4d9ef]:
     [
     !MessagingLtkUser( $Verifier, $VerifierPhone, skVerifier ),
     !UseMessagingKeyFor( $Verifier, $ProverPhone, pkProver ),
     !MessagingApp( $App ), !UseIdPKey( $Verifier, $IdP, pkIdP ),
     E2EE_In( pkProver, pk(skVerifier),
              <'fwd_token', <<$IdP, $App, $Username, nonce, hash>, signature>, salt>
     )
     ]
    --[
    Eq( h(fingerprint(<pkProver, pk(skVerifier)>), salt), hash ),
    Eq( z, true ), DidNotIssueSelf( $Verifier, nonce ),
    ReceivingKey( pk(skVerifier) ),
    AssociateAs( $Verifier, pkProver, $IdP, $Username )
    ]->
     [ ]
    variants (modulo AC)
    1. $App  = $App.17
       $IdP  = $IdP.18
       $Username
             = $Username.20
       hash  = hash.23
       nonce = nonce.24
       pkIdP = pkIdP.25
       signature
             = signature.28
       z     = verify(signature.28,
                      <$IdP.18, $App.17, $Username.20, nonce.24, hash.23>, pkIdP.25)
    
    2. $App  = $App.25
       $IdP  = $IdP.26
       $Username
             = $Username.28
       hash  = hash.31
       nonce = nonce.32
       pkIdP = pk(x.48)
       signature
             = sign(<$IdP.26, $App.25, $Username.28, nonce.32, hash.31>, x.48)
       z     = true
  */

restriction CheckNonceReplay:
  "∀ verifier nonce #t1.
    (DidNotIssueSelf( verifier, nonce ) @ #t1) ⇒
    (¬(∃ #t2. SelfIssued( verifier, nonce ) @ #t2))"
  // safety formula

lemma Executability:
  exists-trace
  "∃ verifier proverKey idp acc verifierKey m1 m2 s1 s2 #t1 #t2 #t3 #t4
     #t5.
    ((((((((AssociateAs( verifier, proverKey, idp, acc ) @ #t1) ∧
           (ReceiveMessaging( proverKey, verifierKey, m1 ) @ #t2)) ∧
          (ReceiveIdP( idp, acc, m2 ) @ #t3)) ∧
         (SendMessaging( proverKey, verifierKey, m1 ) @ #t4)) ∧
        (Sender( s1 ) @ #t4)) ∧
       (SendIdP( idp, acc, m2 ) @ #t5)) ∧
      (Sender( s2 ) @ #t5)) ∧
     (s1 = s2)) ∧
    (¬(∃ #x. SomeCompromise( ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"∃ verifier proverKey idp acc verifierKey m1 m2 s1 s2 #t1 #t2 #t3 #t4
   #t5.
  (AssociateAs( verifier, proverKey, idp, acc ) @ #t1) ∧
  (ReceiveMessaging( proverKey, verifierKey, m1 ) @ #t2) ∧
  (ReceiveIdP( idp, acc, m2 ) @ #t3) ∧
  (SendMessaging( proverKey, verifierKey, m1 ) @ #t4) ∧
  (Sender( s1 ) @ #t4) ∧
  (SendIdP( idp, acc, m2 ) @ #t5) ∧
  (Sender( s2 ) @ #t5) ∧
  (s1 = s2)
 ∧
  ∀ #x. (SomeCompromise( ) @ #x) ⇒ ⊥"
*/
by sorry

lemma SOAPAgreement [reuse]:
  all-traces
  "∀ v proverKey idp acc verifierKey #t1.
    ((AssociateAs( v, proverKey, idp, acc ) @ #t1) ∧
     (ReceivingKey( verifierKey ) @ #t1)) ⇒
    ((((((∃ prover nonce #x1 #x2.
           ((SOAPStart( prover, nonce ) @ #x1) ∧
            (SOAPMessaging( prover, nonce, verifierKey, proverKey ) @ #x1)) ∧
           (SOAPIdP( prover, nonce, idp, acc ) @ #x2)) ∨
         (∃ #x. CompromisedIdP( idp ) @ #x)) ∨
        (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
       (∃ app redirectURL #x #y #z.
         ((IsMessagingApp( app ) @ #x) ∧
          (IsRedirectURL( idp, app, redirectURL ) @ #y)) ∧
         (CompromisedDomain( redirectURL ) @ #z))) ∨
      (∃ p #x. CompromisedAccount( p, idp, acc ) @ #x)) ∨
     (∃ p #x. CompromisedMessaging( p, proverKey ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ v proverKey idp acc verifierKey #t1.
  (AssociateAs( v, proverKey, idp, acc ) @ #t1) ∧
  (ReceivingKey( verifierKey ) @ #t1)
 ∧
  (∀ prover nonce #x1 #x2.
    (SOAPStart( prover, nonce ) @ #x1) ∧
    (SOAPMessaging( prover, nonce, verifierKey, proverKey ) @ #x1) ∧
    (SOAPIdP( prover, nonce, idp, acc ) @ #x2)
   ⇒
    ⊥) ∧
  (∀ #x. (CompromisedIdP( idp ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ app redirectURL #x #y #z.
    (IsMessagingApp( app ) @ #x) ∧
    (IsRedirectURL( idp, app, redirectURL ) @ #y) ∧
    (CompromisedDomain( redirectURL ) @ #z)
   ⇒
    ⊥) ∧
  (∀ p #x. (CompromisedAccount( p, idp, acc ) @ #x) ⇒ ⊥) ∧
  (∀ p #x. (CompromisedMessaging( p, proverKey ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma SocialAuthentication:
  all-traces
  "∀ v proverKey verifierKey m1 idp acc m2 #t1 #t2 #t3.
    (((AssociateAs( v, proverKey, idp, acc ) @ #t1) ∧
      (ReceiveMessaging( proverKey, verifierKey, m1 ) @ #t2)) ∧
     (ReceiveIdP( idp, acc, m2 ) @ #t3)) ⇒
    ((((((∃ s1 s2 #x1 #x2.
           ((((SendMessaging( proverKey, verifierKey, m1 ) @ #x1) ∧
              (Sender( s1 ) @ #x1)) ∧
             (SendIdP( idp, acc, m2 ) @ #x2)) ∧
            (Sender( s2 ) @ #x2)) ∧
           (s1 = s2)) ∨
         (∃ #x. CompromisedIdP( idp ) @ #x)) ∨
        (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
       (∃ app redirectURL #x #y #z.
         ((IsMessagingApp( app ) @ #x) ∧
          (IsRedirectURL( idp, app, redirectURL ) @ #y)) ∧
         (CompromisedDomain( redirectURL ) @ #z))) ∨
      (∃ p #x. CompromisedAccount( p, idp, acc ) @ #x)) ∨
     (∃ p #x. CompromisedMessaging( p, proverKey ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ v proverKey verifierKey m1 idp acc m2 #t1 #t2 #t3.
  (AssociateAs( v, proverKey, idp, acc ) @ #t1) ∧
  (ReceiveMessaging( proverKey, verifierKey, m1 ) @ #t2) ∧
  (ReceiveIdP( idp, acc, m2 ) @ #t3)
 ∧
  (∀ s1 s2 #x1 #x2.
    (SendMessaging( proverKey, verifierKey, m1 ) @ #x1) ∧
    (Sender( s1 ) @ #x1) ∧
    (SendIdP( idp, acc, m2 ) @ #x2) ∧
    (Sender( s2 ) @ #x2) ∧
    (s1 = s2)
   ⇒
    ⊥) ∧
  (∀ #x. (CompromisedIdP( idp ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ app redirectURL #x #y #z.
    (IsMessagingApp( app ) @ #x) ∧
    (IsRedirectURL( idp, app, redirectURL ) @ #y) ∧
    (CompromisedDomain( redirectURL ) @ #z)
   ⇒
    ⊥) ∧
  (∀ p #x. (CompromisedAccount( p, idp, acc ) @ #x) ⇒ ⊥) ∧
  (∀ p #x. (CompromisedMessaging( p, proverKey ) @ #x) ⇒ ⊥)"
*/
by sorry























/*
WARNING: the following wellformedness checks failed!

Derivation Checks
=================

  Derivation checks timed out. Use --derivcheck-timeout=INT to configure timeout, 0 to deactivate.
*/

/*
Generated from:
Tamarin version 1.8.0
Maude version 3.2.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2023-09-02 13:40:44.835695 UTC
*/

end