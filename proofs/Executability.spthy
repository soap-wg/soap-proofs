theory MessagingOIDC begin

// Function signature and definition of the equational theory E

functions: e2ee/3, e2eeDec/2, extract/1, fingerprint/1, fst/1, h/2,
           pair/2, pk/1, s256/1, sign/2, snd/1, true/0, verify/3
equations:
    e2eeDec(e2ee(sks, pk(skr), m), skr) = m,
    extract(fingerprint(x)) = x,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true



restriction OnlyOnce:
  "∀ t #x #y.
    ((OnlyOnce( t ) @ #x) ∧ (OnlyOnce( t ) @ #y)) ⇒ (#x = #y)"
  // safety formula

restriction Equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction Inequality:
  "∀ x #t. (Neq( x, x ) @ #t) ⇒ (⊥)"
  // safety formula



rule (modulo E) Phone:
   [ Fr( ~sim ) ]
  --[ ClaimNumber( $A, $Number ), IsPhoneNumber( $Number ) ]->
   [ !Phone( $A, $Number ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SMSOut[color=#ffffff]:
   [ SMS_Out( $Number, sms ), !Phone( $A, $Number ) ]
  -->
   [ !SMS( $Number, sms ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) AdversarySMSOut[color=#ff6961]:
   [ In( sms ), !Phone( $A, $Number ) ] --> [ !SMS( $Number, sms ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SMSIn[color=#ffffff]:
   [ !SMS( $Number, sms ) ] --> [ SMS_In( $Number, sms ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SMSLeak[color=#ff6961]:
   [ !SMS( $Number, sms ) ]
  --[ SMSLeak( ), SomeCompromise( ) ]->
   [ Out( sms ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Domain:
   [ ] --> [ !Domain( $Domain ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) DomainCompromise:
   [ !Domain( $Domain ) ]
  --[ CompromisedDomain( $Domain ), SomeCompromise( ) ]->
   [ !DomainCompromise( $Domain ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSClientOut[color=#ffffff]:
   [ TLSClient_Out( method, ~sess, $Domain, msg ), !Domain( $Domain )
   ]
  -->
   [ !TLSClient( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSAdversaryClientOut[color=#ff6961]:
   [ In( method ), In( ~sess ), In( msg ), !Domain( $Domain ) ]
  -->
   [ !TLSClient( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSServerOut[color=#ffffff]:
   [ TLSServer_Out( method, ~sess, $Domain, msg ), !Domain( $Domain )
   ]
  -->
   [ !TLSServer( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSAdversaryServerOut[color=#ff6961]:
   [
   In( method ), In( ~sess ), In( msg ), !DomainCompromise( $Domain )
   ]
  -->
   [ !TLSServer( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSClientToServer[color=#ffffff]:
   [ !TLSClient( method, ~sess, $Domain, msg ) ]
  -->
   [ TLSServer_In( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSClientToAdversaryServer[color=#ff6961]:
   [
   !TLSClient( method, ~sess, $Domain, msg ),
   !DomainCompromise( $Domain )
   ]
  -->
   [ Out( msg ), Out( ~sess ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSServerToClient[color=#ffffff]:
   [ !TLSServer( method, ~sess, $Domain, msg ) ]
  -->
   [ TLSClient_In( method, ~sess, $Domain, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSServerToAdversaryClient[color=#ff6961]:
   [
   In( ~adversarySess ),
   !TLSServer( method, ~adversarySess, $Domain, msg )
   ]
  -->
   [ Out( msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPSetup:
   [ !Domain( $IdP ), Fr( ~idpSk ) ]
  -->
   [ !IdP( $IdP ), !IdPLtk( $IdP, ~idpSk ), Out( pk(~idpSk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPCompromise[color=#ff6961]:
   [ !IdPLtk( $IdP, idpSk ) ]
  --[ CompromisedIdP( $IdP ), SomeCompromise( ) ]->
   [ !IdPCompromise( $IdP ), Out( idpSk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPKeyRequest[color=#9ad5d8]:
   [ !IdP( $IdP ), Fr( ~sess ) ]
  -->
   [
   TLSClient_Out( 'GET', ~sess, $IdP, 'pk_req' ),
   St_IdPKeyReq( $IdP, ~sess )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPPkDistribute[color=#9ad5d8]:
   [
   TLSServer_In( 'GET', ~sess, $IdP, 'pk_req' ),
   !IdPLtk( $IdP, idpSk )
   ]
  -->
   [ TLSServer_Out( 'GET', ~sess, $IdP, <'idp_pk', pk(idpSk)> ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) IdPKeyObtain[color=#9ad5d8]:
   [
   St_IdPKeyReq( $IdP, ~sess ),
   TLSClient_In( 'GET', ~sess, $IdP, <'idp_pk', idpPk> )
   ]
  -->
   [ !UseIdPKey( $User, $IdP, idpPk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPSignUp:
   [ Fr( ~pw ), !IdP( $IdP ) ]
  --[ Username( $A, $IdP, $Username, ~pw ) ]->
   [ !IdPAccount( $A, $IdP, $Username, ~pw ) ]

  /* has exactly the trivial AC variant */

restriction AccountsUnique:
  "∀ p1 p2 idp u pw1 pw2 #a #b.
    ((Username( p1, idp, u, pw1 ) @ #a) ∧
     (Username( p2, idp, u, pw2 ) @ #b)) ⇒
    (((p1 = p2) ∧ (pw1 = pw2)) ∧ (#a = #b))"
  // safety formula

rule (modulo E) IdPAccountCompromise[color=#ff6961]:
   [ !IdPAccount( $A, $IdP, $Username, ~pw ) ]
  --[ CompromisedAccount( $A, $IdP, $Username ), SomeCompromise( )
  ]->
   [ Out( ~pw ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPPublishClient:
   [ Fr( ~sess ), Fr( ~m ), !IdPAccount( $A, $IdP, $Username, ~pw ) ]
  --[ SendIdP( $IdP, $Username, ~m ), Sender( $A ) ]->
   [
   TLSClient_Out( 'GET', ~sess, $IdP, <'publish', $Username, ~pw, ~m>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPPublishServer:
   [
   !IdPAccount( p, $IdP, $Username, ~pw ),
   TLSServer_In( 'GET', ~sess, $IdP, <'publish', $Username, ~pw, m> )
   ]
  -->
   [ Out( m ), !Publish( $IdP, $Username, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPPublishCompromised:
   [ !IdPCompromise( $IdP ), In( m ) ]
  -->
   [ !Publish( $IdP, $Username, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdPRead:
   [ !Publish( $IdP, $Username, m ) ]
  --[ ReceiveIdP( $IdP, $Username, m ) ]->
   [ ]

  /* has exactly the trivial AC variant */

lemma PublishExecutability:
  exists-trace
  "∃ user idp m #t.
    (ReceiveIdP( idp, user, m ) @ #t) ∧
    (¬(∃ #x. SomeCompromise( ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"∃ user idp m #t.
  (ReceiveIdP( idp, user, m ) @ #t)
 ∧
  ∀ #x. (SomeCompromise( ) @ #x) ⇒ ⊥"
*/
by sorry

lemma IdPChannelSenderInvariance:
  all-traces
  "∀ user idp m #t.
    (ReceiveIdP( idp, user, m ) @ #t) ⇒
    ((((∃ #x. SendIdP( idp, user, m ) @ #x) ∨
       (∃ #x. CompromisedIdP( idp ) @ #x)) ∨
      (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
     (∃ p #x. CompromisedAccount( p, idp, user ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ user idp m #t.
  (ReceiveIdP( idp, user, m ) @ #t)
 ∧
  (∀ #x. (SendIdP( idp, user, m ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedIdP( idp ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ p #x. (CompromisedAccount( p, idp, user ) @ #x) ⇒ ⊥)"
*/
by sorry

rule (modulo E) KeyServer:
   [ !Domain( $Domain ) ]
  --[ OnlyOnce( 'key_server' ), IsKeyServer( $Domain ) ]->
   [ !KeyServer( $Domain ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingRegister[color=#fdfd96]:
   [
   Fr( ~sk ), Fr( ~sess ), !Phone( $A, $Number ),
   !KeyServer( $KeyServer )
   ]
  --[ IsMessagingKey( ~sk ) ]->
   [
   TLSClient_Out( 'GET', ~sess, $KeyServer,
                  <'msg_signup_req', $Number, pk(~sk)>
   ),
   Out( pk(~sk) ), St_MessagingReg_App( $A, $Number, ~sess, ~sk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingChallenge[color=#fdfd96]:
   [
   Fr( ~challenge ), !KeyServer( $Server ),
   TLSServer_In( 'GET', ~sess, $Server,
                 <'msg_signup_req', $Number, ltk>
   )
   ]
  --[ IsOTP( ~challenge ) ]->
   [
   SMS_Out( $Number, ~challenge ),
   St_SigReg_Server( ~sess, $Number, ltk, ~challenge )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingRespond[color=#fdfd96]:
   [
   !KeyServer( $Server ),
   St_MessagingReg_App( $A, $Number, ~sess, sk ),
   SMS_In( $Number, challenge )
   ]
  --[ MustBeOTP( challenge ) ]->
   [
   TLSClient_Out( 'GET', ~sess, $Server, <'otp_respond', challenge> ),
   St_MessagingReg_AppWait( $A, $Number, ~sess, sk )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) MessagingAck[color=#fdfd96]:
   [
   !KeyServer( $Server ),
   St_SigReg_Server( ~sess, $Number, ltk, challenge ),
   TLSServer_In( 'GET', ~sess, $Server, <'otp_respond', challenge> )
   ]
  --[ MessagingKeyServer( $Number, ltk ) ]->
   [
   !MessagingLtkServer( $Number, ltk ),
   TLSServer_Out( 'GET', ~sess, $Server, 'msg_signup_ack' )
   ]

  // loop breakers: [1,2]
  /* has exactly the trivial AC variant */

restriction KeysUnique:
  "∀ phone ltk1 ltk2 #a #b.
    ((MessagingKeyServer( phone, ltk1 ) @ #a) ∧
     (MessagingKeyServer( phone, ltk2 ) @ #b)) ⇒
    ((#a = #b) ∧ (ltk1 = ltk2))"
  // safety formula

rule (modulo E) MessagingFin[color=#fdfd96]:
   [
   !KeyServer( $Server ),
   St_MessagingReg_AppWait( $A, $Number, ~sess, sk ),
   TLSClient_In( 'GET', ~sess, $Server, 'msg_signup_ack' )
   ]
  --[ ClaimMessagingKey( $A, $Number, sk ) ]->
   [ !MessagingLtkUser( $A, $Number, sk )[no_precomp] ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingCompromise[color=#ff6961]:
   [ !MessagingLtkUser( $A, $Number, ~sk )[no_precomp] ]
  --[ CompromisedMessaging( $A, pk(~sk) ), SomeCompromise( ) ]->
   [ Out( ~sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingKeyRequest[color=#9ad5d8]:
   [
   !MessagingLtkServer( $Number, ltk ), !KeyServer( $Server ),
   TLSServer_In( 'GET', ~sess, $Server, <'msg_key_req', $Number> )
   ]
  --[ MustBeMessagingKey( ltk ) ]->
   [
   TLSServer_Out( 'GET', ~sess, $Server,
                  <'msg_key_resp', $Number, ltk>
   )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) ObtainKey[color=#9ad5d8]:
   [ Fr( ~sess ), !KeyServer( $Server ) ]
  -->
   [
   TLSClient_Out( 'GET', ~sess, $Server, <'msg_key_req', $Phone> ),
   St_KeyReq( $A, $Phone, ~sess )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ObtainKeyFin[color=#9ad5d8]:
   [
   !KeyServer( $Server ), St_KeyReq( $A, $Phone, ~sess ),
   TLSClient_In( 'GET', ~sess, $Server, <'msg_key_resp', $Phone, ltk>
   )
   ]
  -->
   [ !UseMessagingKeyFor( $A, $Phone, ltk )[no_precomp] ]

  /* has exactly the trivial AC variant */

rule (modulo E) SendInterface:
   [ Fr( ~m ) ] --> [ SendAsTo( $A, $Phone, ~m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingSend:
   [
   SendAsTo( $A, $PeerPhone, m ),
   !MessagingLtkUser( $A, $MyPhone, ~sk )[no_precomp],
   !UseMessagingKeyFor( $A, $PeerPhone, ltk )[no_precomp]
   ]
  --[
  SendMessaging( pk(~sk), ltk, m ), Sender( $A ),
  SendTo( $PeerPhone, 'messaging', m )
  ]->
   [ Out( e2ee(~sk, ltk, m) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingReceive:
   [
   !MessagingLtkUser( $A, $MyPhone, ~skr )[no_precomp],
   !UseMessagingKeyFor( $A, $PeerPhone, pk(skPeer) )[no_precomp],
   In( e2ee(skPeer, pk(~skr), m) )
   ]
  --[ ReceiveMessaging( pk(skPeer), pk(~skr), m ) ]->
   [ ]

  /* has exactly the trivial AC variant */

lemma MessagingExecutability:
  exists-trace
  "∃ senderPhone myPhone m #t.
    (ReceiveMessaging( senderPhone, myPhone, m ) @ #t) ∧
    (¬(∃ #x. SomeCompromise( ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"∃ senderPhone myPhone m #t.
  (ReceiveMessaging( senderPhone, myPhone, m ) @ #t)
 ∧
  ∀ #x. (SomeCompromise( ) @ #x) ⇒ ⊥"
*/
by sorry

predicate: KeyServerCompromise( )<=>∃ d #x #y. (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y)

lemma MessagingSenderInvariance:
  all-traces
  "∀ senderKey myKey m #t.
    (ReceiveMessaging( senderKey, myKey, m ) @ #t) ⇒
    ((((∃ #x. SendMessaging( senderKey, myKey, m ) @ #x) ∨
       (∃ d #x #y.
         (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y))) ∨
      (∃ #x. SMSLeak( ) @ #x)) ∨
     (∃ s #x. CompromisedMessaging( s, senderKey ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ senderKey myKey m #t.
  (ReceiveMessaging( senderKey, myKey, m ) @ #t)
 ∧
  (∀ #x. (SendMessaging( senderKey, myKey, m ) @ #x) ⇒ ⊥) ∧
  (∀ d #x #y.
    (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y) ⇒ ⊥) ∧
  (∀ #x. (SMSLeak( ) @ #x) ⇒ ⊥) ∧
  (∀ s #x. (CompromisedMessaging( s, senderKey ) @ #x) ⇒ ⊥)"
*/
by sorry

rule (modulo E) Client:
   [ ] --> [ !Client( $App ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MessagingApp:
   [ !Client( $App ) ]
  --[ IsMessagingApp( $App ), OnlyOnce( 'messaging_app_client' ) ]->
   [ !MessagingApp( $App ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) RedirectURL:
   [ !IdP( $IdP ), !Client( $App ), !Domain( $RedirectURL ) ]
  --[ IsRedirectURL( $IdP, $App, $RedirectURL ) ]->
   [ !RedirectURL( $IdP, $App, $RedirectURL ) ]

  /* has exactly the trivial AC variant */

restriction UniqueRedirectURLs:
  "∀ idp1 idp2 app1 app2 url #t1 #t2 #t3.
    (((IsMessagingApp( app1 ) @ #t1) ∧
      (IsRedirectURL( idp1, app1, url ) @ #t2)) ∧
     (IsRedirectURL( idp2, app2, url ) @ #t3)) ⇒
    ((idp1 = idp2) ∧ (app1 = app2))"
  // safety formula

rule (modulo E) 0_InitSessionStore:
   [ ]
  --[ OnlyOnce( <'init_session_store', $User> ) ]->
   [ SessionStore( $User, 'null', 'null' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ClearSessionStore:
   [ SessionStore( $User, x, y ) ]
  -->
   [ SessionStore( $User, 'null', 'null' ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) LinkClick[color=#ff6961]:
   [ Fr( ~sess ), In( m ), !Domain( $Domain ) ]
  --[ SomeCompromise( ) ]->
   [
   TLSClient_Out( 'GET', ~sess, $Domain, m ),
   !Browser( $Prover, ~sess )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) OIDCAppLaunchBrowser[color=#b4d9ef]:
   [
   !IdP( $IdP ), !MessagingApp( $App ),
   !RedirectURL( $IdP, $App, $RedirectURL ),
   !MessagingLtkUser( $Prover, $ProverPhone, skProver )[no_precomp],
   !UseMessagingKeyFor( $Prover, $VerifierPhone, pkVerifier
   )[no_precomp],
   SessionStore( $Prover, drop1, drop2 ), Fr( salt ), Fr( nonce ),
   Fr( code_verifier ), Fr( ~sess )
   ]
  --[
  IsNonce( nonce ), GenerateCodeVerifierFor( code_verifier, $IdP ),
  SOAPStart( $Prover, nonce ),
  SOAPMessaging( $Prover, nonce, pkVerifier, pk(skProver) )
  ]->
   [
   TLSClient_Out( 'GET', ~sess, $IdP,
                  <'oidc_req', $App, 
                   h(fingerprint(<pk(skProver), pkVerifier>), salt), nonce, 
                   s256(code_verifier), $RedirectURL>
   ),
   Out( <h(fingerprint(<pk(skProver), pkVerifier>), salt), nonce, 
         s256(code_verifier)>
   ),
   SessionStore( $Prover, nonce,
                 <$IdP, $VerifierPhone, 
                  h(fingerprint(<pk(skProver), pkVerifier>), salt), salt, 
                  code_verifier>
   ),
   !Browser( $Prover, ~sess )
   ]

  // loop breaker: [5]
  /* has exactly the trivial AC variant */

rule (modulo E) OIDCIdPInit[color=#b4d9ef]:
   [
   !IdP( $IdP ), !RedirectURL( $IdP, $Client, $RedirectURL ),
   TLSServer_In( 'GET', ~sess, $IdP,
                 <'oidc_req', $Client, hash, nonce, code_challenge, $RedirectURL>
   )
   ]
  --[ MustBeNonce( nonce ) ]->
   [
   TLSServer_Out( 'GET', ~sess, $IdP, 'auth_req' ),
   St_OIDCServer_Auth( $IdP, $Client, $RedirectURL, ~sess, hash,
                       nonce, code_challenge
   )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) OIDCAppLogin[color=#b4d9ef]:
   [
   !Browser( $Prover, ~sess ), !IdP( $IdP ),
   TLSClient_In( 'GET', ~sess, $IdP, 'auth_req' ),
   !IdPAccount( $Prover, $IdP, $Username, ~pw )
   ]
  -->
   [ TLSClient_Out( 'GET', ~sess, $IdP, <'login', $Username, ~pw> ) ]

  /* has exactly the trivial AC variant */

lemma PasswordsConfidential [reuse]:
  all-traces
  "∀ user idp username pw #t1 #t2.
    ((Username( user, idp, username, pw ) @ #t1) ∧ (!KU( pw ) @ #t2)) ⇒
    ((∃ #x. CompromisedDomain( idp ) @ #x) ∨
     (∃ someone #x. CompromisedAccount( someone, idp, username ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ user idp username pw #t1 #t2.
  (Username( user, idp, username, pw ) @ #t1) ∧ (!KU( pw ) @ #t2)
 ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ someone #x.
    (CompromisedAccount( someone, idp, username ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma MessagingKeysUnique [reuse]:
  all-traces
  "∀ userA userB phoneA phoneB sk #a #b.
    ((ClaimMessagingKey( userA, phoneA, sk ) @ #a) ∧
     (ClaimMessagingKey( userB, phoneB, sk ) @ #b)) ⇒
    ((((#a = #b) ∧ (userA = userB)) ∧ (phoneA = phoneB)) ∨
     (∃ d #x #y.
       (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y)))"
/*
guarded formula characterizing all counter-examples:
"∃ userA userB phoneA phoneB sk #a #b.
  (ClaimMessagingKey( userA, phoneA, sk ) @ #a) ∧
  (ClaimMessagingKey( userB, phoneB, sk ) @ #b)
 ∧
  (((¬(#a = #b)) ∨ (¬(userA = userB)) ∨ (¬(phoneA = phoneB)))) ∧
  (∀ d #x #y.
    (IsKeyServer( d ) @ #x) ∧ (CompromisedDomain( d ) @ #y) ⇒ ⊥)"
*/
by sorry

rule (modulo E) OIDCIdPIssueCode[color=#b4d9ef]:
   [
   !IdP( $IdP ), !IdPAccount( $User, $IdP, $Username, pw ),
   Fr( ~code ),
   St_OIDCServer_Auth( $IdP, $Client, $RedirectURL, ~sess, hash,
                       nonce, code_challenge
   ),
   TLSServer_In( 'GET', ~sess, $IdP, <'login', $Username, pw> )
   ]
  --[
  IsCode( ~code ), MustBeNonce( nonce ),
  SOAPIdP( $User, nonce, $IdP, $Username )
  ]->
   [
   TLSClient_Out( 'GET', ~sess, $RedirectURL, <'code', ~code, nonce>
   ),
   St_OIDCIdP_Code( $IdP, $Username, $Client, $RedirectURL, ~code,
                    hash, nonce, code_challenge
   )
   ]

  // loop breaker: [4]
  /* has exactly the trivial AC variant */

rule (modulo E) OIDCAppCodeRedirect[color=#b4d9ef]:
   [
   !RedirectURL( $IdP, $App, $RedirectURL ), !IdP( $IdP ),
   !MessagingApp( $App ), Fr( ~sessPost ),
   SessionStore( $Prover, nonce,
                 <$IdP, $VerifierPhone, hash, salt, code_verifier>
   ),
   !Browser( $Prover, ~sess ),
   TLSServer_In( 'GET', ~sess, $RedirectURL, <'code', code, nonce> )
   ]
  --[
  SelfIssued( $Prover, nonce ), Neq( nonce, 'null' ),
  MustBeCode( code )
  ]->
   [
   TLSClient_Out( 'POST', ~sessPost, $IdP,
                  <'token_req', code, code_verifier, $RedirectURL>
   ),
   St_OIDCApp_CodeReq( $Prover, $IdP, $VerifierPhone, ~sessPost, hash,
                       salt, code
   ),
   SessionStore( $Prover, 'null', 'null' )
   ]

  // loop breaker: [6]
  /* has exactly the trivial AC variant */

rule (modulo E) OIDCIdPTokenIssue[color=#b4d9ef]:
   [
   !IdPLtk( $IdP, idpSk ),
   St_OIDCIdP_Code( $IdP, $Username, $Client, $RedirectURL, code,
                    hash, nonce, code_challenge
   ),
   TLSServer_In( 'POST', ~sess, $IdP,
                 <'token_req', code, code_verifier, $RedirectURL>
   )
   ]
  --[
  Eq( s256(code_verifier), code_challenge ),
  IssueTokenForCode( $IdP, ~sess, code ),
  MustBeToken( <<$IdP, $Client, $Username, nonce, hash>, 
                sign(<$IdP, $Client, $Username, nonce, hash>, idpSk)>
  ),
  UseCode( $IdP, $Client, code ),
  UseCodeVerifierFor( $IdP, code_verifier )
  ]->
   [
   TLSServer_Out( 'POST', ~sess, $IdP,
                  <'token', <$IdP, $Client, $Username, nonce, hash>, 
                   sign(<$IdP, $Client, $Username, nonce, hash>, idpSk)>
   )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

lemma CodeSecrecy [reuse]:
  all-traces
  "∀ idp client code #t1 #t2 #t3.
    (((UseCode( idp, client, code ) @ #t1) ∧
      (IsMessagingApp( client ) @ #t2)) ∧
     (!KU( code ) @ #t3)) ⇒
    (((∃ #x. (UsedCode( idp, code ) @ #x) ∧ (#x < #t3)) ∨
      (∃ url #x #y.
        (IsRedirectURL( idp, client, url ) @ #x) ∧
        (CompromisedDomain( url ) @ #y))) ∨
     (∃ #x. CompromisedDomain( idp ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ idp client code #t1 #t2 #t3.
  (UseCode( idp, client, code ) @ #t1) ∧
  (IsMessagingApp( client ) @ #t2) ∧
  (!KU( code ) @ #t3)
 ∧
  (∀ #x. (UsedCode( idp, code ) @ #x) ⇒ ¬(#x < #t3)) ∧
  (∀ url #x #y.
    (IsRedirectURL( idp, client, url ) @ #x) ∧
    (CompromisedDomain( url ) @ #y)
   ⇒
    ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma CodeVerifierSecrecy [reuse]:
  all-traces
  "∀ verifier idp #x #y.
    ((UseCodeVerifierFor( idp, verifier ) @ #x) ∧
     (GenerateCodeVerifierFor( verifier, idp ) @ #y)) ⇒
    ((¬(∃ #z. !KU( verifier ) @ #z)) ∨
     (∃ #z. CompromisedDomain( idp ) @ #z))"
/*
guarded formula characterizing all counter-examples:
"∃ verifier idp #x #y.
  (UseCodeVerifierFor( idp, verifier ) @ #x) ∧
  (GenerateCodeVerifierFor( verifier, idp ) @ #y)
 ∧
  (∃ #z. (!KU( verifier ) @ #z)) ∧
  (∀ #z. (CompromisedDomain( idp ) @ #z) ⇒ ⊥)"
*/
by sorry

lemma TokenFormatAndOTPLearning [sources]:
  all-traces
  "((((∀ token #i.
        (MustBeToken( token ) @ #i) ⇒
        (∃ first second user idp client nonce hashed sk.
          ((((token = <first, second>) ∧
             (first = <idp, client, user, nonce, hashed>)) ∧
            ((∃ #h. (!KU( nonce ) @ #h) ∧ (#h < #i)) ∨
             (∃ #h. IsNonce( nonce ) @ #h))) ∧
           ((∃ #h. (!KU( hashed ) @ #h) ∧ (#h < #i)) ∨
            (∃ fp salt. hashed = h(fp, salt)))) ∧
          (second = sign(first, sk)))) ∧
      (∀ nonce #i.
        (MustBeNonce( nonce ) @ #i) ⇒
        ((∃ #h. (!KU( nonce ) @ #h) ∧ (#h < #i)) ∨
         (∃ #h. IsNonce( nonce ) @ #h)))) ∧
     (∀ code #i.
       (MustBeCode( code ) @ #i) ⇒
       ((∃ #h. (!KU( code ) @ #h) ∧ (#h < #i)) ∨
        (∃ #h. IsCode( code ) @ #h)))) ∧
    (∀ chall #i.
      (MustBeOTP( chall ) @ #i) ⇒
      ((∃ #j. (IsOTP( chall ) @ #j) ∧ (#j < #i)) ∨
       (∃ #j. (!KU( chall ) @ #j) ∧ (#j < #i))))) ∧
   (∀ ltk #i.
     (MustBeMessagingKey( ltk ) @ #i) ⇒
     ((∃ sk #j. (IsMessagingKey( sk ) @ #j) ∧ (ltk = pk(sk))) ∨
      (∃ #j. (!KU( ltk ) @ #j) ∧ (#j < #i))))"
/*
guarded formula characterizing all counter-examples:
"((∃ token #i.
    (MustBeToken( token ) @ #i)
   ∧
    ∀ first second user idp client nonce hashed sk.
     (token = <first, second>) ∧
     (first = <idp, client, user, nonce, hashed>) ∧
     (second = sign(first, sk))
    ⇒
     (((∀ #h. (!KU( nonce ) @ #h) ⇒ ¬(#h < #i)) ∧
       (∀ #h. (IsNonce( nonce ) @ #h) ⇒ ⊥)) ∨
      ((∀ #h. (!KU( hashed ) @ #h) ⇒ ¬(#h < #i)) ∧
       (∀ fp salt. (hashed = h(fp, salt)) ⇒ ⊥)))) ∨
  (∃ nonce #i.
    (MustBeNonce( nonce ) @ #i)
   ∧
    (∀ #h. (!KU( nonce ) @ #h) ⇒ ¬(#h < #i)) ∧
    (∀ #h. (IsNonce( nonce ) @ #h) ⇒ ⊥)) ∨
  (∃ code #i.
    (MustBeCode( code ) @ #i)
   ∧
    (∀ #h. (!KU( code ) @ #h) ⇒ ¬(#h < #i)) ∧
    (∀ #h. (IsCode( code ) @ #h) ⇒ ⊥)) ∨
  (∃ chall #i.
    (MustBeOTP( chall ) @ #i)
   ∧
    (∀ #j. (IsOTP( chall ) @ #j) ⇒ ¬(#j < #i)) ∧
    (∀ #j. (!KU( chall ) @ #j) ⇒ ¬(#j < #i))) ∨
  (∃ ltk #i.
    (MustBeMessagingKey( ltk ) @ #i)
   ∧
    (∀ sk #j. (IsMessagingKey( sk ) @ #j) ∧ (ltk = pk(sk)) ⇒ ⊥) ∧
    (∀ #j. (!KU( ltk ) @ #j) ⇒ ¬(#j < #i))))"
*/
by sorry

rule (modulo E) OIDCTokenForward[color=#b4d9ef]:
   [
   !IdP( $IdP ), !MessagingApp( $App ),
   !UseMessagingKeyFor( $Prover, $VerifierPhone, pkVerifier
   )[no_precomp],
   !UseIdPKey( $Prover, $IdP, pkIdP ),
   !MessagingLtkUser( $Prover, $ProverPhone, skProver )[no_precomp],
   St_OIDCApp_CodeReq( $Prover, $IdP, $VerifierPhone, ~sessPost, hash,
                       salt, code
   ),
   TLSClient_In( 'POST', ~sessPost, $IdP,
                 <'token', <$IdP, $App, $Username, nonce, hash>, signature>
   )
   ]
  --[
  Eq( h(fingerprint(<pk(skProver), pkVerifier>), salt), hash ),
  Eq( verify(signature, <$IdP, $App, $Username, nonce, hash>, pkIdP),
      true
  ),
  GetTokenForCode( $IdP, ~sessPost, code ),
  MustBeToken( <<$IdP, $App, $Username, nonce, hash>, signature> ),
  MustBeCode( code ), UsedCode( $IdP, code )
  ]->
   [
   SendAsTo( $Prover, $VerifierPhone,
             <'fwd_token', <<$IdP, $App, $Username, nonce, hash>, signature>, 
              salt>
   ),
   Out( code )
   ]

  /*
  rule (modulo AC) OIDCTokenForward[color=#b4d9ef]:
     [
     !IdP( $IdP ), !MessagingApp( $App ),
     !UseMessagingKeyFor( $Prover, $VerifierPhone, pkVerifier
     )[no_precomp],
     !UseIdPKey( $Prover, $IdP, pkIdP ),
     !MessagingLtkUser( $Prover, $ProverPhone, skProver )[no_precomp],
     St_OIDCApp_CodeReq( $Prover, $IdP, $VerifierPhone, ~sessPost, hash,
                         salt, code
     ),
     TLSClient_In( 'POST', ~sessPost, $IdP,
                   <'token', <$IdP, $App, $Username, nonce, hash>, signature>
     )
     ]
    --[
    Eq( h(fingerprint(<pk(skProver), pkVerifier>), salt), hash ),
    Eq( z, true ), GetTokenForCode( $IdP, ~sessPost, code ),
    MustBeToken( <<$IdP, $App, $Username, nonce, hash>, signature> ),
    MustBeCode( code ), UsedCode( $IdP, code )
    ]->
     [
     SendAsTo( $Prover, $VerifierPhone,
               <'fwd_token', <<$IdP, $App, $Username, nonce, hash>, signature>, 
                salt>
     ),
     Out( code )
     ]
    variants (modulo AC)
    1. $App  = $App.34
       $IdP  = $IdP.35
       $Username
             = $Username.38
       hash  = hash.42
       nonce = nonce.43
       pkIdP = pkIdP.44
       signature
             = signature.47
       z     = verify(signature.47,
                      <$IdP.35, $App.34, $Username.38, nonce.43, hash.42>, pkIdP.44)
    
    2. $App  = $App.69
       $IdP  = $IdP.70
       $Username
             = $Username.73
       hash  = hash.77
       nonce = nonce.78
       pkIdP = pk(x.136)
       signature
             = sign(<$IdP.70, $App.69, $Username.73, nonce.78, hash.77>, x.136)
       z     = true
  */

lemma CodeAgreement [use_induction, reuse]:
  all-traces
  "∀ idp sess codeClient codeIdP #t1 #t2.
    ((GetTokenForCode( idp, sess, codeClient ) @ #t1) ∧
     (IssueTokenForCode( idp, sess, codeIdP ) @ #t2)) ⇒
    ((codeClient = codeIdP) ∨ (∃ #x. CompromisedDomain( idp ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ idp sess codeClient codeIdP #t1 #t2.
  (GetTokenForCode( idp, sess, codeClient ) @ #t1) ∧
  (IssueTokenForCode( idp, sess, codeIdP ) @ #t2)
 ∧
  (¬(codeClient = codeIdP)) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma CodeIsSingleUse [reuse]:
  all-traces
  "∀ idp code #a #b.
    ((UsedCode( idp, code ) @ #a) ∧ (UsedCode( idp, code ) @ #b)) ⇒
    (((#a = #b) ∨ (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
     (∃ app url #x #y.
       (IsRedirectURL( idp, app, url ) @ #x) ∧
       (CompromisedDomain( url ) @ #y)))"
/*
guarded formula characterizing all counter-examples:
"∃ idp code #a #b.
  (UsedCode( idp, code ) @ #a) ∧ (UsedCode( idp, code ) @ #b)
 ∧
  (¬(#a = #b)) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ app url #x #y.
    (IsRedirectURL( idp, app, url ) @ #x) ∧
    (CompromisedDomain( url ) @ #y)
   ⇒
    ⊥)"
*/
by sorry

rule (modulo E) OIDCTokenReceive[color=#b4d9ef]:
   [
   !MessagingLtkUser( $Verifier, $VerifierPhone, skVerifier
   )[no_precomp],
   !UseMessagingKeyFor( $Verifier, $ProverPhone, pk(skProver)
   )[no_precomp],
   !MessagingApp( $App ), !UseIdPKey( $Verifier, $IdP, pkIdP ),
   In( e2ee(skProver, pk(skVerifier),
            <'fwd_token', <<$IdP, $App, $Username, nonce, hash>, signature>, 
             salt>)
   )
   ]
  --[
  Eq( h(fingerprint(<pk(skProver), pk(skVerifier)>), salt), hash ),
  Eq( verify(signature, <$IdP, $App, $Username, nonce, hash>, pkIdP),
      true
  ),
  DidNotIssueSelf( $Verifier, nonce ),
  ReceivingKey( pk(skVerifier) ),
  Correspond( $Verifier, pk(skProver), $IdP, $Username )
  ]->
   [ ]

  /*
  rule (modulo AC) OIDCTokenReceive[color=#b4d9ef]:
     [
     !MessagingLtkUser( $Verifier, $VerifierPhone, skVerifier
     )[no_precomp],
     !UseMessagingKeyFor( $Verifier, $ProverPhone, pk(skProver)
     )[no_precomp],
     !MessagingApp( $App ), !UseIdPKey( $Verifier, $IdP, pkIdP ),
     In( e2ee(skProver, pk(skVerifier),
              <'fwd_token', <<$IdP, $App, $Username, nonce, hash>, signature>, 
               salt>)
     )
     ]
    --[
    Eq( h(fingerprint(<pk(skProver), pk(skVerifier)>), salt), hash ),
    Eq( z, true ), DidNotIssueSelf( $Verifier, nonce ),
    ReceivingKey( pk(skVerifier) ),
    Correspond( $Verifier, pk(skProver), $IdP, $Username )
    ]->
     [ ]
    variants (modulo AC)
    1. $App  = $App.17
       $IdP  = $IdP.18
       $Username
             = $Username.20
       hash  = hash.23
       nonce = nonce.24
       pkIdP = pkIdP.25
       signature
             = signature.27
       z     = verify(signature.27,
                      <$IdP.18, $App.17, $Username.20, nonce.24, hash.23>, pkIdP.25)
    
    2. $App  = $App.25
       $IdP  = $IdP.26
       $Username
             = $Username.28
       hash  = hash.31
       nonce = nonce.32
       pkIdP = pk(x.48)
       signature
             = sign(<$IdP.26, $App.25, $Username.28, nonce.32, hash.31>, x.48)
       z     = true
  */

restriction CheckNonceReplay:
  "∀ verifier nonce #t1.
    (DidNotIssueSelf( verifier, nonce ) @ #t1) ⇒
    (¬(∃ #t2. SelfIssued( verifier, nonce ) @ #t2))"
  // safety formula

lemma Executability:
  exists-trace
  "∃ verifier proverKey idp acc verifierKey m1 m2 s1 s2 #t1 #t2 #t3
     #t4 #t5.
    ((((((((Correspond( verifier, proverKey, idp, acc ) @ #t1) ∧
           (ReceiveMessaging( proverKey, verifierKey, m1 ) @ #t2)) ∧
          (ReceiveIdP( idp, acc, m2 ) @ #t3)) ∧
         (SendMessaging( proverKey, verifierKey, m1 ) @ #t4)) ∧
        (Sender( s1 ) @ #t4)) ∧
       (SendIdP( idp, acc, m2 ) @ #t5)) ∧
      (Sender( s2 ) @ #t5)) ∧
     (s1 = s2)) ∧
    (¬(∃ #x. SomeCompromise( ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"∃ verifier proverKey idp acc verifierKey m1 m2 s1 s2 #t1 #t2 #t3
   #t4 #t5.
  (Correspond( verifier, proverKey, idp, acc ) @ #t1) ∧
  (ReceiveMessaging( proverKey, verifierKey, m1 ) @ #t2) ∧
  (ReceiveIdP( idp, acc, m2 ) @ #t3) ∧
  (SendMessaging( proverKey, verifierKey, m1 ) @ #t4) ∧
  (Sender( s1 ) @ #t4) ∧
  (SendIdP( idp, acc, m2 ) @ #t5) ∧
  (Sender( s2 ) @ #t5) ∧
  (s1 = s2)
 ∧
  ∀ #x. (SomeCompromise( ) @ #x) ⇒ ⊥"
*/
simplify
solve( Sender( s1 ) @ #t4 )
  case MessagingSend
  solve( Sender( $A.1 ) @ #t5 )
    case IdPPublishClient
    solve( !MessagingLtkUser( $Verifier, $VerifierPhone, skVerifier
           )[no_precomp] ▶₀ #t1 )
      case MessagingFin_case_1
      solve( !UseMessagingKeyFor( $Verifier, $ProverPhone, pk(~sk.1)
             )[no_precomp] ▶₁ #t1 )
        case ObtainKeyFin_case_1
        solve( !MessagingApp( $App ) ▶₂ #t1 )
          case MessagingApp
          solve( !UseIdPKey( $Verifier, $IdP, pk(x) ) ▶₃ #t1 )
            case IdPKeyObtain_case_1
            solve( !KU( e2ee(~sk.1, pk(~sk),
                             <'fwd_token', 
                              <
                               <$IdP, $App, $Username, nonce, 
                                h(fingerprint(<pk(~sk.1), pk(~sk)>), salt)>, 
                               sign(<$IdP, $App, $Username, nonce, 
                                     h(fingerprint(<pk(~sk.1), pk(~sk)>), salt)>,
                                    ~idpSk)
                              >, 
                              salt>)
                   ) @ #vk )
              case MessagingSend_case_01
              by contradiction /* from formulas */
            next
              case MessagingSend_case_02
              by contradiction /* from formulas */
            next
              case MessagingSend_case_03
              by contradiction /* from formulas */
            next
              case MessagingSend_case_04
              by contradiction /* from formulas */
            next
              case MessagingSend_case_05
              by contradiction /* from formulas */
            next
              case MessagingSend_case_06
              by contradiction /* from formulas */
            next
              case MessagingSend_case_07
              by contradiction /* from formulas */
            next
              case MessagingSend_case_08
              by contradiction /* from formulas */
            next
              case MessagingSend_case_09
              by contradiction /* from formulas */
            next
              case MessagingSend_case_10
              by contradiction /* from formulas */
            next
              case MessagingSend_case_11
              by contradiction /* from formulas */
            next
              case MessagingSend_case_12
              by contradiction /* from formulas */
            next
              case MessagingSend_case_13
              by contradiction /* from formulas */
            next
              case MessagingSend_case_14
              by contradiction /* from formulas */
            next
              case MessagingSend_case_15
              by contradiction /* from formulas */
            next
              case MessagingSend_case_16
              by contradiction /* from formulas */
            next
              case MessagingSend_case_17
              solve( !MessagingLtkUser( $A, $MyPhone, ~skr )[no_precomp] ▶₀ #t2 )
                case MessagingFin_case_1
                solve( !UseMessagingKeyFor( $A, $PeerPhone, pk(~sk.1)
                       )[no_precomp] ▶₁ #t2 )
                  case ObtainKeyFin_case_1
                  solve( !KU( e2ee(~sk.1, pk(~skr), m1) ) @ #vk.1 )
                    case MessagingSend_case_01
                    solve( !Publish( $IdP, $Username, ~m.1 ) ▶₀ #t3 )
                      case IdPPublishCompromised
                      by contradiction /* from formulas */
                    next
                      case IdPPublishServer_case_1
                      solve( SendAsTo( $User, $PeerPhone.1, ~m ) ▶₀ #t4 )
                        case SendInterface
                        solve( SMS_In( $VerifierPhone, challenge ) ▶₂ #vr.2 )
                          case SMSIn_case_1
                          solve( St_SigReg_Server( ~sess.1, $Number, ltk, challenge.1
                                 ) ▶₁ #vr.8 )
                            case MessagingChallenge_case_1
                            solve( TLSServer_In( 'GET', ~sess.1, $Server,
                                                 <'otp_respond', ~challenge.1>
                                   ) ▶₂ #vr.8 )
                              case TLSClientToServer_case_1
                              solve( TLSServer_In( 'GET', ~sess.2, $Server,
                                                   <'msg_key_req', $ProverPhone>
                                     ) ▶₂ #vr.14 )
                                case TLSClientToServer_case_1
                                solve( St_SigReg_Server( ~sess.5, $ProverPhone, pk(~sk.1),
                                                         challenge.1
                                       ) ▶₁ #vr.16 )
                                  case MessagingChallenge_case_1
                                  solve( TLSServer_In( 'GET', ~sess.5, $Server,
                                                       <'otp_respond', ~challenge.1>
                                         ) ▶₂ #vr.16 )
                                    case TLSClientToServer_case_1
                                    solve( TLSServer_In( 'GET', ~sess.3, $IdP, 'pk_req'
                                           ) ▶₀ #vr.25 )
                                      case TLSClientToServer_case_1
                                      solve( !UseMessagingKeyFor( $User, $PeerPhone.2, pk(~sk)
                                             )[no_precomp] ▶₂ #vr.30 )
                                        case ObtainKeyFin_case_1
                                        solve( !MessagingLtkUser( $User, $ProverPhone.1, ~sk.1
                                               )[no_precomp] ▶₄ #vr.30 )
                                          case MessagingFin
                                          solve( TLSServer_In( 'GET', ~sess.7, $RedirectURL,
                                                               <'code', code.1, ~n.1>
                                                 ) ▶₆ #vr.33 )
                                            case TLSClientToServer_case_1
                                            solve( !MessagingLtkUser( $User, $ProverPhone.1, ~sk.1
                                                   )[no_precomp] ▶₃ #vr.40 )
                                              case MessagingFin
                                              solve( !UseMessagingKeyFor( $User, $PeerPhone.2,
                                                                          pk(~sk)
                                                     )[no_precomp] ▶₄ #vr.40 )
                                                case ObtainKeyFin_case_1
                                                solve( !MessagingLtkUser( $User, $ProverPhone.1,
                                                                          skProver
                                                       )[no_precomp] ▶₃ #vr.41 )
                                                  case MessagingFin_case_1
                                                  solve( !UseMessagingKeyFor( $User, $VerifierPhone,
                                                                              pkVerifier
                                                         )[no_precomp] ▶₄ #vr.41 )
                                                    case ObtainKeyFin_case_1
                                                    solve( TLSServer_In( 'POST', ~sessPost, $IdP,
                                                                         <'token_req', ~code, 
                                                                          code_verifier, 
                                                                          $RedirectURL.3>
                                                           ) ▶₂ #vr.53 )
                                                      case TLSClientToServer_case_1
                                                      solve( (∀ #z. (!KU( ~n.2 ) @ #z) ⇒ ⊥)  ∥
                                                             (∃ #z.
                                                               (CompromisedDomain( $IdP ) @ #z)) )
                                                        case case_1
                                                        solve( TLSServer_In( 'GET', ~sess.4, $IdP,
                                                                             'pk_req'
                                                               ) ▶₀ #vr.56 )
                                                          case TLSClientToServer_case_1
                                                          solve( TLSServer_In( 'GET', ~sess.7, $IdP,
                                                                               <'login', $Username, 
                                                                                ~pw>
                                                                 ) ▶₄ #vr.67 )
                                                            case TLSClientToServer_case_1
                                                            solve( TLSServer_In( 'GET', ~sess.7,
                                                                                 $IdP,
                                                                                 <'oidc_req', $App, 
                                                                                  h(fingerprint(<
                                                                                                 pk(~sk.1), 
                                                                                                 pk(~sk)
                                                                                                >),
                                                                                    ~n.1), 
                                                                                  ~n, s256(~n.2), 
                                                                                  $RedirectURL>
                                                                   ) ▶₂ #vr.72 )
                                                              case TLSClientToServer_case_1
                                                              solve( SMS_In( $ProverPhone,
                                                                             ~challenge.1
                                                                     ) ▶₂ #vr.76 )
                                                                case SMSIn_case_1
                                                                solve( St_SigReg_Server( ~sess.5,
                                                                                         $Number.1,
                                                                                         ltk,
                                                                                         challenge.2
                                                                       ) ▶₁ #vr.81 )
                                                                  case MessagingChallenge_case_1
                                                                  solve( TLSServer_In( 'GET',
                                                                                       ~sess.7,
                                                                                       $Server,
                                                                                       <
                                                                                        'msg_key_req', 
                                                                                        $VerifierPhone
                                                                                       >
                                                                         ) ▶₂ #vr.86 )
                                                                    case TLSClientToServer_case_1
                                                                    solve( St_SigReg_Server( ~sess.13,
                                                                                             $VerifierPhone,
                                                                                             pk(~sk),
                                                                                             challenge.2
                                                                           ) ▶₁ #vr.88 )
                                                                      case MessagingChallenge_case_1
                                                                      solve( SMS_In( $MyPhone,
                                                                                     challenge.2
                                                                             ) ▶₂ #vr.89 )
                                                                        case SMSIn_case_1
                                                                        solve( St_SigReg_Server( ~sess.8,
                                                                                                 $Number.1,
                                                                                                 ltk,
                                                                                                 challenge.3
                                                                               ) ▶₁ #vr.94 )
                                                                          case MessagingChallenge_case_1
                                                                          solve( TLSServer_In( 'GET',
                                                                                               ~sess.8,
                                                                                               $Server,
                                                                                               <
                                                                                                'otp_respond', 
                                                                                                ~challenge.3
                                                                                               >
                                                                                 ) ▶₂ #vr.94 )
                                                                            case TLSClientToServer_case_1
                                                                            solve( TLSServer_In( 'GET',
                                                                                                 ~sess.9,
                                                                                                 $Server,
                                                                                                 <
                                                                                                  'msg_key_req', 
                                                                                                  $PeerPhone
                                                                                                 >
                                                                                   ) ▶₂ #vr.100 )
                                                                              case TLSClientToServer_case_1
                                                                              solve( St_SigReg_Server( ~sess.13,
                                                                                                       $PeerPhone,
                                                                                                       pk(~sk.1),
                                                                                                       challenge.3
                                                                                     ) ▶₁ #vr.102 )
                                                                                case MessagingChallenge_case_1
                                                                                solve( TLSServer_In( 'GET',
                                                                                                     ~sess.10,
                                                                                                     $Server,
                                                                                                     <
                                                                                                      'msg_key_req', 
                                                                                                      $PeerPhone.1
                                                                                                     >
                                                                                       ) ▶₂ #vr.107 )
                                                                                  case TLSClientToServer_case_1
                                                                                  solve( St_SigReg_Server( ~sess.13,
                                                                                                           $PeerPhone.1,
                                                                                                           pk(~skr),
                                                                                                           challenge.3
                                                                                         ) ▶₁ #vr.109 )
                                                                                    case MessagingChallenge_case_1
                                                                                    solve( TLSServer_In( 'GET',
                                                                                                         ~sess.11,
                                                                                                         $Server,
                                                                                                         <
                                                                                                          'msg_key_req', 
                                                                                                          $Number
                                                                                                         >
                                                                                           ) ▶₂ #vr.140 )
                                                                                      case TLSClientToServer_case_1
                                                                                      solve( TLSServer_In( 'GET',
                                                                                                           ~sess.12,
                                                                                                           $Server,
                                                                                                           <
                                                                                                            'msg_key_req', 
                                                                                                            $Number
                                                                                                           >
                                                                                             ) ▶₂ #vr.149 )
                                                                                        case TLSClientToServer_case_1
                                                                                        solve( TLSServer_In( 'GET',
                                                                                                             ~sess.6,
                                                                                                             $IdP,
                                                                                                             <
                                                                                                              'oidc_req', 
                                                                                                              $Client, 
                                                                                                              hash, 
                                                                                                              nonce, 
                                                                                                              code_challenge, 
                                                                                                              $RedirectURL.1
                                                                                                             >
                                                                                               ) ▶₂ #vr.165 )
                                                                                          case TLSClientToServer_case_1
                                                                                          solve( SessionStore( $User,
                                                                                                               drop1,
                                                                                                               drop2
                                                                                                 ) ▶₅ #vr.40 )
                                                                                            case 0_InitSessionStore
                                                                                            SOLVED // trace found
                                                                                          next
                                                                                            case ClearSessionStore
                                                                                            by sorry
                                                                                          next
                                                                                            case OIDCAppCodeRedirect_case_1
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppCodeRedirect_case_2
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppCodeRedirect_case_3
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppCodeRedirect_case_4
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppCodeRedirect_case_5
                                                                                            by sorry
                                                                                          next
                                                                                            case OIDCAppCodeRedirect_case_6
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppCodeRedirect_case_7
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppCodeRedirect_case_8
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppLaunchBrowser_case_1
                                                                                            by sorry
                                                                                          next
                                                                                            case OIDCAppLaunchBrowser_case_2
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppLaunchBrowser_case_3
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          next
                                                                                            case OIDCAppLaunchBrowser_case_4
                                                                                            by contradiction
                                                                                               /*
                                                                                               from formulas
                                                                                               */
                                                                                          qed
                                                                                        next
                                                                                          case TLSClientToServer_case_2
                                                                                          by sorry
                                                                                        qed
                                                                                      next
                                                                                        case TLSClientToServer_case_2
                                                                                        by sorry
                                                                                      qed
                                                                                    next
                                                                                      case TLSClientToServer_case_2
                                                                                      by sorry
                                                                                    qed
                                                                                  next
                                                                                    case MessagingChallenge_case_2
                                                                                    by contradiction
                                                                                       /*
                                                                                       from formulas
                                                                                       */
                                                                                  next
                                                                                    case MessagingChallenge_case_3
                                                                                    by sorry
                                                                                  qed
                                                                                next
                                                                                  case TLSClientToServer_case_2
                                                                                  by sorry
                                                                                qed
                                                                              next
                                                                                case MessagingChallenge_case_2
                                                                                by contradiction
                                                                                   /* from formulas
                                                                                   */
                                                                              next
                                                                                case MessagingChallenge_case_3
                                                                                by sorry
                                                                              qed
                                                                            next
                                                                              case TLSClientToServer_case_2
                                                                              by sorry
                                                                            qed
                                                                          next
                                                                            case TLSClientToServer_case_2
                                                                            by sorry
                                                                          qed
                                                                        next
                                                                          case MessagingChallenge_case_2
                                                                          by sorry
                                                                        qed
                                                                      next
                                                                        case SMSIn_case_2
                                                                        by contradiction
                                                                           /* from formulas */
                                                                      next
                                                                        case SMSIn_case_3
                                                                        by sorry
                                                                      next
                                                                        case SMSIn_case_4
                                                                        by sorry
                                                                      qed
                                                                    next
                                                                      case MessagingChallenge_case_2
                                                                      by contradiction
                                                                         /* from formulas */
                                                                    next
                                                                      case MessagingChallenge_case_3
                                                                      by sorry
                                                                    qed
                                                                  next
                                                                    case TLSClientToServer_case_2
                                                                    by sorry
                                                                  qed
                                                                next
                                                                  case MessagingChallenge_case_2
                                                                  by sorry
                                                                qed
                                                              next
                                                                case SMSIn_case_2
                                                                by sorry
                                                              qed
                                                            next
                                                              case TLSClientToServer_case_2
                                                              by sorry
                                                            qed
                                                          next
                                                            case TLSClientToServer_case_2
                                                            by contradiction /* from formulas */
                                                          next
                                                            case TLSClientToServer_case_3
                                                            by sorry
                                                          qed
                                                        next
                                                          case TLSClientToServer_case_2
                                                          by sorry
                                                        qed
                                                      next
                                                        case case_2
                                                        by contradiction /* from formulas */
                                                      qed
                                                    next
                                                      case TLSClientToServer_case_2
                                                      by sorry
                                                    qed
                                                  next
                                                    case ObtainKeyFin_case_2
                                                    by contradiction /* from formulas */
                                                  qed
                                                next
                                                  case MessagingFin_case_2
                                                  by contradiction /* from formulas */
                                                qed
                                              next
                                                case ObtainKeyFin_case_2
                                                by contradiction /* from formulas */
                                              qed
                                            qed
                                          next
                                            case TLSClientToServer_case_2
                                            by sorry
                                          qed
                                        qed
                                      next
                                        case ObtainKeyFin_case_2
                                        by contradiction /* from formulas */
                                      qed
                                    next
                                      case TLSClientToServer_case_2
                                      by sorry
                                    qed
                                  next
                                    case TLSClientToServer_case_2
                                    by sorry
                                  qed
                                next
                                  case MessagingChallenge_case_2
                                  by contradiction /* from formulas */
                                next
                                  case MessagingChallenge_case_3
                                  by sorry
                                qed
                              next
                                case TLSClientToServer_case_2
                                by sorry
                              qed
                            next
                              case TLSClientToServer_case_2
                              by sorry
                            qed
                          next
                            case MessagingChallenge_case_2
                            by sorry
                          qed
                        next
                          case SMSIn_case_2
                          by contradiction /* from formulas */
                        next
                          case SMSIn_case_3
                          by sorry
                        next
                          case SMSIn_case_4
                          by sorry
                        qed
                      qed
                    next
                      case IdPPublishServer_case_2
                      by contradiction /* from formulas */
                    next
                      case IdPPublishServer_case_3
                      by sorry
                    qed
                  next
                    case MessagingSend_case_02
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_03
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_04
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_05
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_06
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_07
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_08
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_09
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_10
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_11
                    by sorry
                  next
                    case MessagingSend_case_12
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_13
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_14
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_15
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_16
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_17
                    by contradiction /* from formulas */
                  next
                    case MessagingSend_case_18
                    by contradiction /* from formulas */
                  next
                    case c_e2ee
                    by sorry
                  qed
                next
                  case ObtainKeyFin_case_2
                  by contradiction /* from formulas */
                qed
              next
                case MessagingFin_case_2
                by contradiction /* from formulas */
              qed
            next
              case MessagingSend_case_18
              by contradiction /* from formulas */
            next
              case MessagingSend_case_19
              by contradiction /* from formulas */
            next
              case MessagingSend_case_20
              by contradiction /* from formulas */
            next
              case MessagingSend_case_21
              by contradiction /* from formulas */
            next
              case MessagingSend_case_22
              by contradiction /* from formulas */
            next
              case MessagingSend_case_23
              by contradiction /* from formulas */
            next
              case MessagingSend_case_24
              by contradiction /* from formulas */
            next
              case MessagingSend_case_25
              by contradiction /* from formulas */
            next
              case MessagingSend_case_26
              by contradiction /* from formulas */
            next
              case MessagingSend_case_27
              by contradiction /* from formulas */
            next
              case MessagingSend_case_28
              by contradiction /* from formulas */
            next
              case MessagingSend_case_29
              by contradiction /* from formulas */
            next
              case MessagingSend_case_30
              by contradiction /* from formulas */
            next
              case MessagingSend_case_31
              by contradiction /* from formulas */
            next
              case MessagingSend_case_32
              by contradiction /* from formulas */
            next
              case c_e2ee
              by sorry
            qed
          next
            case IdPKeyObtain_case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case ObtainKeyFin_case_2
        by contradiction /* from formulas */
      qed
    next
      case MessagingFin_case_2
      by contradiction /* from formulas */
    qed
  qed
qed

lemma SOAPAgreement [reuse]:
  all-traces
  "∀ v proverKey idp acc verifierKey #t1.
    ((Correspond( v, proverKey, idp, acc ) @ #t1) ∧
     (ReceivingKey( verifierKey ) @ #t1)) ⇒
    ((((((∃ prover nonce #x1 #x2.
           ((SOAPStart( prover, nonce ) @ #x1) ∧
            (SOAPMessaging( prover, nonce, verifierKey, proverKey ) @ #x1)) ∧
           (SOAPIdP( prover, nonce, idp, acc ) @ #x2)) ∨
         (∃ #x. CompromisedIdP( idp ) @ #x)) ∨
        (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
       (∃ app redirectURL #x #y #z.
         ((IsMessagingApp( app ) @ #x) ∧
          (IsRedirectURL( idp, app, redirectURL ) @ #y)) ∧
         (CompromisedDomain( redirectURL ) @ #z))) ∨
      (∃ p #x. CompromisedAccount( p, idp, acc ) @ #x)) ∨
     (∃ p #x. CompromisedMessaging( p, proverKey ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ v proverKey idp acc verifierKey #t1.
  (Correspond( v, proverKey, idp, acc ) @ #t1) ∧
  (ReceivingKey( verifierKey ) @ #t1)
 ∧
  (∀ prover nonce #x1 #x2.
    (SOAPStart( prover, nonce ) @ #x1) ∧
    (SOAPMessaging( prover, nonce, verifierKey, proverKey ) @ #x1) ∧
    (SOAPIdP( prover, nonce, idp, acc ) @ #x2)
   ⇒
    ⊥) ∧
  (∀ #x. (CompromisedIdP( idp ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ app redirectURL #x #y #z.
    (IsMessagingApp( app ) @ #x) ∧
    (IsRedirectURL( idp, app, redirectURL ) @ #y) ∧
    (CompromisedDomain( redirectURL ) @ #z)
   ⇒
    ⊥) ∧
  (∀ p #x. (CompromisedAccount( p, idp, acc ) @ #x) ⇒ ⊥) ∧
  (∀ p #x. (CompromisedMessaging( p, proverKey ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma SocialAuthentication:
  all-traces
  "∀ v sendKey rcvKey m1 idp acc m2 #t #r1 #r2.
    (((Correspond( v, sendKey, idp, acc ) @ #t) ∧
      (ReceiveMessaging( sendKey, rcvKey, m1 ) @ #r1)) ∧
     (ReceiveIdP( idp, acc, m2 ) @ #r2)) ⇒
    ((((((∃ s #x1 #x2.
           (((((SendMessaging( sendKey, rcvKey, m1 ) @ #x1) ∧
               (Sender( s ) @ #x1)) ∧
              (#x1 < #r1)) ∧
             (SendIdP( idp, acc, m2 ) @ #x2)) ∧
            (Sender( s ) @ #x2)) ∧
           (#x2 < #r2)) ∨
         (∃ #x. CompromisedIdP( idp ) @ #x)) ∨
        (∃ #x. CompromisedDomain( idp ) @ #x)) ∨
       (∃ app redirectURL #x #y #z.
         ((IsMessagingApp( app ) @ #x) ∧
          (IsRedirectURL( idp, app, redirectURL ) @ #y)) ∧
         (CompromisedDomain( redirectURL ) @ #z))) ∨
      (∃ p #x. CompromisedAccount( p, idp, acc ) @ #x)) ∨
     (∃ p #x. CompromisedMessaging( p, sendKey ) @ #x))"
/*
guarded formula characterizing all counter-examples:
"∃ v sendKey rcvKey m1 idp acc m2 #t #r1 #r2.
  (Correspond( v, sendKey, idp, acc ) @ #t) ∧
  (ReceiveMessaging( sendKey, rcvKey, m1 ) @ #r1) ∧
  (ReceiveIdP( idp, acc, m2 ) @ #r2)
 ∧
  (∀ s #x1 #x2.
    (SendMessaging( sendKey, rcvKey, m1 ) @ #x1) ∧
    (Sender( s ) @ #x1) ∧
    (SendIdP( idp, acc, m2 ) @ #x2) ∧
    (Sender( s ) @ #x2)
   ⇒
    ((¬(#x1 < #r1)) ∨ (¬(#x2 < #r2)))) ∧
  (∀ #x. (CompromisedIdP( idp ) @ #x) ⇒ ⊥) ∧
  (∀ #x. (CompromisedDomain( idp ) @ #x) ⇒ ⊥) ∧
  (∀ app redirectURL #x #y #z.
    (IsMessagingApp( app ) @ #x) ∧
    (IsRedirectURL( idp, app, redirectURL ) @ #y) ∧
    (CompromisedDomain( redirectURL ) @ #z)
   ⇒
    ⊥) ∧
  (∀ p #x. (CompromisedAccount( p, idp, acc ) @ #x) ⇒ ⊥) ∧
  (∀ p #x. (CompromisedMessaging( p, sendKey ) @ #x) ⇒ ⊥)"
*/
by sorry



























/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.8.0
Maude version 3.1
Git revision: f172d7f00b1485446a1e7a42dc14623c2189cc42, branch: master
Compiled at: 2023-08-31 10:43:56.765388839 UTC
*/

end