theory MessagingOIDC
begin

heuristic: o "./oracle.py"

#include "src/header.spthy"
#include "src/tls.spthy"
#include "src/idp.spthy"
#include "src/messaging.spthy"

rule Client:
  []
  --[ IsClient($Client) ]->
  [ !Client($App) ]

rule MessagingApp:
  [ !Client($App) ]
  --[ OnlyOnce('messaging_app_client') ]->
  [ !MessagingApp($App) ]

rule RedirectURL:
  [ !IdP($IdP), !Client($App), !Domain($RedirectURL) ]
  -->
  [ !RedirectURL($IdP, $App, $RedirectURL) ]

// Clients need to memorize which query they issued last
rule InitSessionStore:
  []
  --[ OnlyOnce(<'init_session_store', $User>) ]->
  [ SessionStore($User, 'null', 'null') ]

rule ClearSessionStore:
  [ SessionStore($User, x, y) ]
  -->
  [ SessionStore($User, 'null', 'null') ]

// It is necessary handle forwards from the adversary dedicatedly, because
// otherwise, the adversary can choose the session they forward to. This would
// be unrealistic, though.
rule LinkClick:
  [ Fr(~sess), In(m), !Domain($Domain) ]
  --[ GenBrowserSession($Prover, $Domain, ~sess)
    , AdversaryLinkClick()
    , SomeCompromise() ]->
  [ TLSClient_Out(~sess, $Domain, m)
  , Browser($Prover, $Domain, ~sess) ]

// OpenID Connect Auth code + PKCE flow
rule OIDCAppLaunchBrowser:
  let fp = fingerprint(<pk(skProver), pkVerifier>)
      hash = h(fp, salt)
      code_challenge = s256(code_verifier)
  in
  [ !IdP($IdP), !MessagingApp($App)
  , !RedirectURL($IdP, $App, $RedirectURL)
  , !MessagingLtkUser($Prover, $ProverPhone, skProver)
  , !UseMessagingKeyFor($Prover, $VerifierPhone, pkVerifier)
  , SessionStore($Prover, drop1, drop2)
  , Fr(salt), Fr(nonce), Fr(code_verifier), Fr(~sess) ]
  --[ GenNonce(nonce)
    , GenBrowserSession($Prover, $IdP, ~sess)
    , GenerateCodeVerifierFor(code_verifier, $IdP)
    , IsCodeChallenge(code_challenge) ]->
  [ TLSClient_Out(~sess, $IdP, <'oidc_req', $App, hash, nonce, code_challenge, $RedirectURL>)
  // This Out fact models that the adversary can access authorization requests
  // (if taken together with the previous Out fact).
  , Out(<hash, nonce, code_challenge>)
  , SessionStore($Prover, nonce, <$IdP, $VerifierPhone, hash, salt, code_verifier>)
  , Browser($Prover, $IdP, ~sess) ]

rule OIDCIdPInit:
  [ !IdP($IdP)
  , !RedirectURL($IdP, $Client, $RedirectURL)
  , TLSServer_In(~sess, $IdP, <'oidc_req', $Client, hash, nonce, code_challenge, $RedirectURL>) ]
  --[ MustBeNonce(nonce) ]->
  [ TLSServer_Out(~sess, $IdP, 'auth_req')
  , St_OIDCServer_Auth($IdP, $Client, $RedirectURL, ~sess, hash, nonce, code_challenge) ]

rule OIDCAppLogin:
  [ Browser($Prover, $IdP, ~sess)
  , !IdP($IdP)
  , TLSClient_In(~sess, $IdP, 'auth_req')
  , !IdPAccount($Prover, $IdP, $Username, ~pw) ]
  --[ UseBrowserSession($Prover, $IdP, ~sess) ]->
  [ TLSClient_Out(~sess, $IdP, <'login', $Username, ~pw>)
  , Browser($Prover, $IdP, ~sess) ]

// lemma BrowserSessionSources[reuse,use_induction]:
//   "   All user domain sess #x. UseBrowserSession(user, domain, sess) @ #x
//   ==> Ex user domain #y. GenBrowserSession(user, domain, sess) @ #y & #y < #x"

// lemma BrowserSessionBinding[reuse,use_induction]:
//   "   All user1 user2 domain1 domain2 sess #x #y.
//         UseBrowserSession(user1, domain1, sess) @ #x
//         & GenBrowserSession(user2, domain2, sess) @ #y
//   ==> user1 = user2 & domain1 = domain2"

// lemma BrowserSessionUnique[reuse,use_induction]:
//   "   All user1 user2 domain1 domain2 sess #x #y.
//         GenBrowserSession(user1, domain1, sess) @ #x
//         & GenBrowserSession(user2, domain2, sess) @ #y
//   ==> #x = #y"

// lemma UsernamesUnique[reuse]:
//   "All userA userB idp username pw1 pw2 #a #b.
//       ClaimUsername(userA, idp, username, pw1) @ #a
//       & ClaimUsername(userB, idp, username, pw2) @ #b
//   ==> (#a = #b & userA = userB)
//       | (Ex sk #t. CompromisedDomain(idp, sk) @ #t)"

// lemma UsernamesServerConfirmed[reuse]:
//   "All user idp username pw #t. ClaimUsername(user, idp, username, pw) @ #t
//   ==> (Ex #x. UsernameServer(idp, username, pw) @ #x)
//       | (Ex sk #x. CompromisedDomain(idp, sk) @ #x)"

// lemma PasswordsConfidential[reuse]:
//   "All user idp username pw #t. UsernameApp(user, idp, username, pw) @ #t
//   ==> not (Ex #x. !KU(pw) @ #x)
//       | (Ex sk #x. CompromisedDomain(idp, sk) @ #x)
//       | (Ex someone #x. CompromisedAccount(someone, idp, username) @ #x)"

// lemma MessagingKeysUnique[reuse]:
//   "All userA userB sk #a #b.
//       ClaimMessagingKey(userA, sk) @ #a
//       & ClaimMessagingKey(userB, sk) @ #b
//   ==> (#a = #b & userA = userB)
//       | (Ex messaging sk #t1 #t2. CompromisedDomain(messaging, sk) @ #t1
//           & IsMessaging(messaging) @ #t2)"

rule OIDCIdPIssueCode:
  [ !IdP($IdP)
  , !IdPAccount($User, $IdP, $Username, pw)
  , Fr(~code), Fr(~sess2)
  , St_OIDCServer_Auth($IdP, $Client, $RedirectURL, ~sess, hash, nonce, code_challenge)
  , TLSServer_In(~sess, $IdP, <'login', $Username, pw>) ]
  --[ IdPIssueCode($IdP, $Username, ~code)
    , IsPW(pw)
    , IsCode(~code)
    , MustBeNonce(nonce)
    , GenCode($IdP, ~code) ]->
  [ TLSClient_Out(~sess2, $RedirectURL, <'code', ~code, nonce>)
  , St_OIDCIdP_Code($IdP, $Username, $Client, ~code, hash, nonce, code_challenge) ]

// lemma IsPW[reuse]:
//   "All pw #x. IsPW(pw) @ #x
//   ==>   (Ex u i un #y. UsernameApp(u, i, un, pw) @ #y)
//       | (Ex #y. !KU(pw) @ #y)"

// lemma UserAccountRequiresSignUp[reuse]:
//   "All u i un pw #x. ClaimUsername(u, i, un, pw) @ #x
//   ==>   (Ex #y. UsernameApp(u, i, un, pw) @ #y)
//       | (Ex d #y. CompromisedDomain(i, d) @ #y)"

rule OIDCAppCodeRedirect:
  // Do not pattern match who the browser session was initiated for. The Messaging
  // app cannot verify this. It is only critical that the adversary could not
  // choose the session.
  [ !RedirectURL($IdP, $App, $RedirectURL), !IdP($IdP)
  , !MessagingApp($App)
  , Fr(~sessPost)
  , SessionStore($Prover, nonce, <$IdP, verifier, hash, salt, code_verifier>)
  , TLSServer_In(~sess, $RedirectURL, <'code', code, nonce>) ]
  --[ AppReceiveCode($Prover, $IdP, code)
    , SelfIssued($Prover, nonce)
    , Neq(nonce, 'null')
    , MustBeCode(code) ]->
  [ TLSClient_Out(~sessPost, $IdP, <'token_req', code, code_verifier>)
  , St_OIDCApp_CodeReq($Prover, $IdP, verifier, ~sessPost, hash, salt, code)
  , SessionStore($Prover, 'null', 'null') ]

rule OIDCIdPTokenIssue:
  let tokenBody = <$IdP, $Client, $Username, nonce, hash>
      token = <tokenBody, sign(tokenBody, sk)>
  in
  [ !IdPLtk($IdP, sk)
  , St_OIDCIdP_Code($IdP, $Username, $Client, code, hash, nonce, code_challenge)
  , TLSServer_In(~sess, $IdP, <'token_req', code, code_verifier>) ]
  --[ Eq(s256(code_verifier), code_challenge)
    , IdPIssueToken(token)
    , MustBeToken(token)
    , UseCode(code)
    , UseCodeVerifierFor(code_verifier, $IdP) ]->
  [ TLSServer_Out(~sess, $IdP, <'token', token>) ]

// lemma CodeVerifierSecrecy[reuse]:
//   "   All verifier idp #x #y.
//         UseCodeVerifierFor(verifier, idp) @ #x
//         & GenerateCodeVerifierFor(verifier, idp) @ #y
//   ==> not (Ex #z. !KU(verifier) @ #z)
//       | (Ex domain #z. CompromisedDomain(idp, domain) @ #z)"

// This sources lemma combines multiple in spirit, but they need to assist each
// other in the proof, hence, they are combined.
lemma TokenFormatAndOTPLearning[sources]:
  "(All token #i.
        MustBeToken(token) @ #i
    ==> (Ex first second user idp client nonce hashed sk.
            token = <first, second>
          & first = <idp, client, user, nonce, hashed>
          & ((Ex #h. !KU(idp) @ #h & #h < #i) | (Ex #h. IsIdP(idp) @ #h))
          & ((Ex #h. !KU(client) @ #h & #h < #i) | (Ex #h. IsClient(client) @ #h))
          & ((Ex #h. !KU(user) @ #h & #h < #i) | (Ex #h. IsUser(user) @ #h))
          & ((Ex #h. !KU(nonce) @ #h & #h < #i) | (Ex #h. GenNonce(nonce) @ #h))
          & ((Ex #h. !KU(hashed) @ #h & #h < #i) | (Ex fp salt. hashed = h(fp, salt)))
          & second = sign(first, sk))
  ) & (All nonce #i.
        MustBeNonce(nonce) @ #i
    ==> ( (Ex #h. !KU(nonce) @ #h & #h < #i)
        | (Ex #h. GenNonce(nonce) @ #h)))
  & (All code #i.
        MustBeCode(code) @ #i
    ==> ( (Ex #h. !KU(code) @ #h & #h < #i)
        | (Ex #h. IsCode(code) @ #h)))
  & (All chall #i.
        MustBeOTP(chall) @ #i
    ==> ( (Ex #j. IsOTP(chall) @ #j & #j < #i)
      | (Ex #j. !KU(chall) @ #j & #j < #i)))
  & (All ltk #i.
        MustBeMessagingKey(ltk) @ #i
    ==> ( (Ex sk #j. IsMessagingKey(sk) @ #j & ltk = pk(sk))
      | (Ex #j. !KU(ltk) @ #j & #j < #i)))"

rule OIDCTokenForward:
  let body = <$IdP, $App, username, nonce, hash>
      fp = fingerprint(<pk(skProver), pkVerifier>)
      token = <body, signature>
  in
  [ !IdP($IdP), !MessagingApp($App)
  , !UseMessagingKeyFor($Prover, verifier, pkVerifier)
  , !UseIdPKey($Prover, $IdP, pkIdP)
  , !MessagingLtkUser($Prover, $ProverPhone, skProver)
  , St_OIDCApp_CodeReq($Prover, $IdP, verifier, ~sessPost, hash, salt, code)
  // We do not check the nonce in the ID token. This is to highlight that the
  // inclusion of a true nonce in the ID token is not strictly necessary in the
  // protocols design.
  , TLSClient_In(~sessPost, $IdP, <'token', <<$IdP, $App, username, nonce, hash>, signature>>) ]
  --[ Eq(h(fp, salt), hash)
    , Eq(verify(signature, body, pkIdP), true)
    , Forward($Prover, token)
    , MustBeToken(token)
    , MustBeCode(code)
    , UsedCode(code) ]->
  [ SendAsTo($Prover, verifier, <'fwd_token', token, salt>)
  // Sending the code models that the adversary can access the authorization
  // response after the fact.
  , Out(code) ]

// lemma CodeIsSingleUse[use_induction,reuse]:
//   " All idp code #a #b #x #y. GenCode(idp, code) @ #a & UsedCode(code) @ #b
//       & UseCode(code) @ #x & UseCode(code) @ #y
//     ==> #x = #y
//       | (Ex domain #x. CompromisedDomain(idp, domain) @ #x)
//       | (Ex messagingApp domain #x #y. IsMessagingAppFor(idp, messagingApp) @ #x
//         & CompromisedDomain(messagingApp, domain) @ #y)"

rule OIDCTokenReceive:
  let body = <$IdP, $App, username, nonce, hash>
      fp = fingerprint(<pkSender, pk(skVerifier)>)
  in
  [ !MessagingLtkUser($Verifier, $VerifierPhone, skVerifier)
  , !MessagingApp($App)
  , !UseIdPKey($Verifier, $IdP, pkIdP)
  , E2EE_In(pkSender, pk(skVerifier), <'fwd_token', <body, signature>, salt>) ]
  --[ Eq(h(fp, salt), hash)
    , Eq(verify(signature, body, pkIdP), true)
    , DidNotIssueSelf($Verifier, nonce)
    , AssociateAs($Verifier, pkSender, $IdP, username)]->
  []

restriction CheckNonceReplay:
  "All verifier nonce #t1.
      DidNotIssueSelf(verifier, nonce) @ #t1
  ==> (not Ex #t2. SelfIssued(verifier, nonce) @ #t2)"

lemma Executability:
  exists-trace
  "Ex verifier pkProver idp acc prover skProver pw #t1 #t2 #t3.
      AssociateAs(verifier, pkProver, idp, acc) @ #t1
    & ClaimMessagingKey(prover, skProver) @ #t2 & pkProver = pk(skProver)
    & Username(prover, idp, acc, pw) @ #t3
    & (not Ex #x. SomeCompromise() @ #x)"

lemma SocialAuthentication:
  "All v proverPhone verifierPhone m1 idp acc m2 #t1 #t2 #t3.
        ( AssociateAs(v, proverPhone, idp, acc) @ #t1
        & ReceiveMessaging(proverPhone, verifierPhone, m1) @ #t2
        & ReceiveIdP(idp, acc, m2) @ #t3)
    ==> ( (Ex s1 s2 #x1 #x2.
          ( SendMessaging(proverPhone, verifierPhone, m1) @ #x1 & Sender(s1) @ #x1
          & SendIdP(idp, acc, m2) @ #x2 & Sender(s2) @ #x2
          & s1 = s2))
        | (Ex #x. CompromisedIdP(idp) @ #x)
        | (Ex #x. CompromisedDomain(idp) @ #x)
        | (Ex p #x. CompromisedAccount(p, idp, acc) @ #x)
        | (Ex p k #x. CompromisedMessaging(p, proverPhone, k) @ #x))"

end
