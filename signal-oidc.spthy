theory MessagingOIDC
begin

heuristic: o "./oracle.py"

#include "src/header.spthy"
#include "src/tls.spthy"
#include "src/idp.spthy"
#include "src/messaging.spthy"

rule Client:
  []
  -->
  [ !Client($App) ]

rule MessagingApp:
  [ !Client($App) ]
  --[ IsMessagingApp($App)
    , OnlyOnce('messaging_app_client') ]->
  [ !MessagingApp($App) ]

rule RedirectURL:
  [ !IdP($IdP), !Client($App), !Domain($RedirectURL) ]
  --[ IsRedirectURL($IdP, $App, $RedirectURL) ]->
  [ !RedirectURL($IdP, $App, $RedirectURL) ]

// Clients need to memorize which query they issued last
rule InitSessionStore:
  []
  --[ OnlyOnce(<'init_session_store', $User>) ]->
  [ SessionStore($User, 'null', 'null') ]

rule ClearSessionStore:
  [ SessionStore($User, x, y) ]
  -->
  [ SessionStore($User, 'null', 'null') ]

// It is necessary handle forwards from the adversary dedicatedly, because
// otherwise, the adversary can choose the session they forward to. This would
// be unrealistic, though.
rule LinkClick[color=#FF6961]:
  [ Fr(~sess), In(m), !Domain($Domain) ]
  --[ GenBrowserSession($Prover, $Domain, ~sess)
    , AdversaryLinkClick()
    , SomeCompromise() ]->
  [ TLSClient_Out('GET', ~sess, $Domain, m)
  , Browser($Prover, $Domain, ~sess) ]

// OpenID Connect Auth code + PKCE flow
rule OIDCAppLaunchBrowser[color=#B4D9EF]:
  let fp = fingerprint(<pk(skProver), pkVerifier>)
      hash = h(fp, salt)
      code_challenge = s256(code_verifier)
  in
  [ !IdP($IdP), !MessagingApp($App)
  , !RedirectURL($IdP, $App, $RedirectURL)
  , !MessagingLtkUser($Prover, $ProverPhone, skProver)
  , !UseMessagingKeyFor($Prover, $VerifierPhone, pkVerifier)
  , SessionStore($Prover, drop1, drop2)
  , Fr(salt), Fr(nonce), Fr(code_verifier), Fr(~sess) ]
  --[ GenNonce(nonce)
    , GenBrowserSession($Prover, $IdP, ~sess)
    , GenerateCodeVerifierFor(code_verifier, $IdP)
    , IsCodeChallenge(code_challenge) ]->
  [ TLSClient_Out('GET', ~sess, $IdP, <'oidc_req', $App, hash, nonce, code_challenge, $RedirectURL>)
  // This Out fact models that the adversary can access authorization requests
  // (if taken together with the previous Out fact).
  , Out(<hash, nonce, code_challenge>)
  , SessionStore($Prover, nonce, <$IdP, $VerifierPhone, hash, salt, code_verifier>)
  , Browser($Prover, $IdP, ~sess) ]

rule OIDCIdPInit[color=#B4D9EF]:
  [ !IdP($IdP)
  , !RedirectURL($IdP, $Client, $RedirectURL)
  , TLSServer_In('GET', ~sess, $IdP, <'oidc_req', $Client, hash, nonce, code_challenge, $RedirectURL>) ]
  --[ MustBeNonce(nonce) ]->
  [ TLSServer_Out('GET', ~sess, $IdP, 'auth_req')
  , St_OIDCServer_Auth($IdP, $Client, $RedirectURL, ~sess, hash, nonce, code_challenge) ]

rule OIDCAppLogin[color=#B4D9EF]:
  [ Browser($Prover, $IdP, ~sess)
  , !IdP($IdP)
  , TLSClient_In('GET', ~sess, $IdP, 'auth_req')
  , !IdPAccount($Prover, $IdP, $Username, ~pw) ]
  --[ UseBrowserSession($Prover, $IdP, ~sess) ]->
  [ TLSClient_Out('GET', ~sess, $IdP, <'login', $Username, ~pw>)
  , Browser($Prover, $IdP, ~sess) ]

// lemma UsernamesUnique[reuse]:
//   "All userA userB idp username pw1 pw2 #a #b.
//       ClaimUsername(userA, idp, username, pw1) @ #a
//       & ClaimUsername(userB, idp, username, pw2) @ #b
//   ==> (#a = #b & userA = userB)
//       | (Ex sk #t. CompromisedDomain(idp, sk) @ #t)"

// lemma UsernamesServerConfirmed[reuse]:
//   "All user idp username pw #t. ClaimUsername(user, idp, username, pw) @ #t
//   ==> (Ex #x. UsernameServer(idp, username, pw) @ #x)
//       | (Ex sk #x. CompromisedDomain(idp, sk) @ #x)"

lemma PasswordsConfidential[reuse]:
  "All user idp username pw #t1 #t2.
        ( Username(user, idp, username, pw) @ #t1
        & KU(pw) @ #t2)
    ==> ( (Ex #x. CompromisedDomain(idp) @ #x)
        | (Ex someone #x. CompromisedAccount(someone, idp, username) @ #x))"

// lemma MessagingKeysUnique[reuse]:
//   "All userA userB sk #a #b.
//       ClaimMessagingKey(userA, sk) @ #a
//       & ClaimMessagingKey(userB, sk) @ #b
//   ==> (#a = #b & userA = userB)
//       | (Ex messaging sk #t1 #t2. CompromisedDomain(messaging, sk) @ #t1
//           & IsMessaging(messaging) @ #t2)"

rule OIDCIdPIssueCode[color=#B4D9EF]:
  [ !IdP($IdP)
  , !IdPAccount($User, $IdP, $Username, pw)
  , Fr(~code), Fr(~sess2)
  , St_OIDCServer_Auth($IdP, $Client, $RedirectURL, ~sess, hash, nonce, code_challenge)
  , TLSServer_In('GET', ~sess, $IdP, <'login', $Username, pw>) ]
  --[ IdPIssueCode($IdP, $Username, ~code)
    , IsPW(pw)
    , IsCode(~code)
    , MustBeNonce(nonce)
    , GenCode($IdP, ~code) ]->
  [ TLSClient_Out('GET', ~sess2, $RedirectURL, <'code', ~code, nonce>)
  , St_OIDCIdP_Code($IdP, $Username, $Client, ~code, hash, nonce, code_challenge) ]

// lemma IsPW[reuse]:
//   "All pw #x. IsPW(pw) @ #x
//   ==>   (Ex u i un #y. UsernameApp(u, i, un, pw) @ #y)
//       | (Ex #y. KU(pw) @ #y)"

// lemma UserAccountRequiresSignUp[reuse]:
//   "All u i un pw #x. ClaimUsername(u, i, un, pw) @ #x
//   ==>   (Ex #y. UsernameApp(u, i, un, pw) @ #y)
//       | (Ex d #y. CompromisedDomain(i, d) @ #y)"

rule OIDCAppCodeRedirect[color=#B4D9EF]:
  // Do not pattern match who the browser session was initiated for. The Messaging
  // app cannot verify this. It is only critical that the adversary could not
  // choose the session.
  [ !RedirectURL($IdP, $App, $RedirectURL), !IdP($IdP)
  , !MessagingApp($App)
  , Fr(~sessPost)
  , SessionStore($Prover, nonce, <$IdP, $VerifierPhone, hash, salt, code_verifier>)
  , TLSServer_In('GET', ~sess, $RedirectURL, <'code', code, nonce>) ]
  --[ AppReceiveCode($Prover, $IdP, code)
    , SelfIssued($Prover, nonce)
    , Neq(nonce, 'null')
    , MustBeCode(code) ]->
  [ TLSClient_Out('POST', ~sessPost, $IdP, <'token_req', code, code_verifier>)
  , St_OIDCApp_CodeReq($Prover, $IdP, $VerifierPhone, ~sessPost, hash, salt, code)
  , SessionStore($Prover, 'null', 'null') ]

rule OIDCIdPTokenIssue[color=#B4D9EF]:
  let tokenBody = <$IdP, $Client, $Username, nonce, hash>
      token = <tokenBody, sign(tokenBody, sk)>
  in
  [ !IdPLtk($IdP, sk)
  , St_OIDCIdP_Code($IdP, $Username, $Client, code, hash, nonce, code_challenge)
  , TLSServer_In('POST', ~sess, $IdP, <'token_req', code, code_verifier>) ]
  --[ Eq(s256(code_verifier), code_challenge)
    , IssueTokenForCode($IdP, ~sess, code)
    , MustBeToken(token)
    , UseCode($IdP, $Client, code)
    , UseCodeVerifierFor($IdP, code_verifier) ]->
  [ TLSServer_Out('POST', ~sess, $IdP, <'token', token>) ]

lemma CodeSecrecy[reuse]:
  "All idp client code #t1 #t2 #t3.
        ( UseCode(idp, client, code) @ #t1
        & IsMessagingApp(client) @ #t2
        & KU(code) @ #t3)
    ==> ( (Ex #x. UsedCode(idp, code) @ #x & #x < #t3)
        | (Ex url #x #y. IsRedirectURL(idp, client, url) @ #x & CompromisedDomain(url) @ #y)
        | (Ex #x. CompromisedDomain(idp) @ #x))"

lemma CodeVerifierSecrecy[reuse]:
  "   All verifier idp #x #y.
        UseCodeVerifierFor(idp, verifier) @ #x
        & GenerateCodeVerifierFor(verifier, idp) @ #y
  ==> not (Ex #z. KU(verifier) @ #z)
      | (Ex #z. CompromisedDomain(idp) @ #z)"

// This sources lemma combines multiple in spirit, but they need to assist each
// other in the proof, hence, they are combined.
lemma TokenFormatAndOTPLearning[sources]:
  "(All token #i.
        MustBeToken(token) @ #i
    ==> (Ex first second user idp client nonce hashed sk.
            token = <first, second>
          & first = <idp, client, user, nonce, hashed>
          & ((Ex #h. KU(nonce) @ #h & #h < #i) | (Ex #h. GenNonce(nonce) @ #h))
          & ((Ex #h. KU(hashed) @ #h & #h < #i) | (Ex fp salt. hashed = h(fp, salt)))
          & second = sign(first, sk))
  ) & (All nonce #i.
        MustBeNonce(nonce) @ #i
    ==> ( (Ex #h. KU(nonce) @ #h & #h < #i)
        | (Ex #h. GenNonce(nonce) @ #h)))
  & (All code #i.
        MustBeCode(code) @ #i
    ==> ( (Ex #h. KU(code) @ #h & #h < #i)
        | (Ex #h. IsCode(code) @ #h)))
  & (All chall #i.
        MustBeOTP(chall) @ #i
    ==> ( (Ex #j. IsOTP(chall) @ #j & #j < #i)
      | (Ex #j. KU(chall) @ #j & #j < #i)))
  & (All ltk #i.
        MustBeMessagingKey(ltk) @ #i
    ==> ( (Ex sk #j. IsMessagingKey(sk) @ #j & ltk = pk(sk))
      | (Ex #j. KU(ltk) @ #j & #j < #i)))"

rule OIDCTokenForward[color=#B4D9EF]:
  let body = <$IdP, $App, $Username, nonce, hash>
      fp = fingerprint(<pk(skProver), pkVerifier>)
      token = <body, signature>
  in
  [ !IdP($IdP), !MessagingApp($App)
  , !UseMessagingKeyFor($Prover, $VerifierPhone, pkVerifier)
  , !UseIdPKey($Prover, $IdP, pkIdP)
  , !MessagingLtkUser($Prover, $ProverPhone, skProver)
  , St_OIDCApp_CodeReq($Prover, $IdP, $VerifierPhone, ~sessPost, hash, salt, code)
  // We do not check the nonce in the ID token. This is to highlight that the
  // inclusion of a true nonce in the ID token is not strictly necessary in the
  // protocols design.
  , TLSClient_In('POST', ~sessPost, $IdP, <'token', <<$IdP, $App, $Username, nonce, hash>, signature>>) ]
  --[ Eq(h(fp, salt), hash)
    , Eq(verify(signature, body, pkIdP), true)
    , GetTokenForCode($IdP, ~sessPost, code)
    , Forward($Prover, token)
    , MustBeToken(token)
    , MustBeCode(code)
    , UsedCode($IdP, code) ]->
  [ SendAsTo($Prover, $VerifierPhone, <'fwd_token', token, salt>)
  // Sending the code models that the adversary can access the authorization
  // response after the fact.
  , Out(code) ]

lemma CodeAgreement[use_induction,reuse]:
  "All idp sess codeClient codeIdP #t1 #t2.
          GetTokenForCode(idp, sess, codeClient) @ #t1
        & IssueTokenForCode(idp, sess, codeIdP) @ #t2
    ==> ( (codeClient = codeIdP)
        | (Ex #x. CompromisedDomain(idp) @ #x))"

lemma CodeIsSingleUse[reuse]:
  "All idp code #a #b.
        (UsedCode(idp, code) @ #a & UsedCode(idp, code) @ #b)
    ==> ( #a = #b
        | (Ex #x. CompromisedDomain(idp) @ #x)
        | (Ex app url #x #y.
              IsRedirectURL(idp, app, url) @ #x
            & CompromisedDomain(url) @ #y))"

rule OIDCTokenReceive[color=#B4D9EF]:
  let body = <$IdP, $App, $Username, nonce, hash>
      fp = fingerprint(<pkProver, pk(skVerifier)>)
  in
  [ !MessagingLtkUser($Verifier, $VerifierPhone, skVerifier)
  , !UseMessagingKeyFor($Verifier, $ProverPhone, pkProver)
  , !MessagingApp($App)
  , !UseIdPKey($Verifier, $IdP, pkIdP)
  , E2EE_In(pkProver, pk(skVerifier), <'fwd_token', <body, signature>, salt>) ]
  --[ Eq(h(fp, salt), hash)
    , Eq(verify(signature, body, pkIdP), true)
    , DidNotIssueSelf($Verifier, nonce)
    , AssociateAs($Verifier, $ProverPhone, $IdP, $Username) ]->
  []

restriction CheckNonceReplay:
  "All verifier nonce #t1.
      DidNotIssueSelf(verifier, nonce) @ #t1
  ==> (not Ex #t2. SelfIssued(verifier, nonce) @ #t2)"

lemma Executability:
  exists-trace
  "Ex verifier pkProver idp acc prover skProver pw #t1 #t2 #t3.
      AssociateAs(verifier, pkProver, idp, acc) @ #t1
    & ClaimMessagingKey(prover, skProver) @ #t2 & pkProver = pk(skProver)
    & Username(prover, idp, acc, pw) @ #t3
    & (not Ex #x. SomeCompromise() @ #x)"

lemma SocialAuthentication:
  "All v proverPhone verifierPhone m1 idp acc m2 #t1 #t2 #t3.
        ( AssociateAs(v, proverPhone, idp, acc) @ #t1
        & ReceiveMessaging(proverPhone, verifierPhone, m1) @ #t2
        & ReceiveIdP(idp, acc, m2) @ #t3)
    ==> ( (Ex s1 s2 #x1 #x2.
          ( SendMessaging(proverPhone, verifierPhone, m1) @ #x1 & Sender(s1) @ #x1
          & SendIdP(idp, acc, m2) @ #x2 & Sender(s2) @ #x2
          & s1 = s2))
        | (Ex #x. CompromisedIdP(idp) @ #x)
        | (Ex #x. CompromisedDomain(idp) @ #x)
        | (Ex p #x. CompromisedAccount(p, idp, acc) @ #x)
        | (Ex p k #x. CompromisedMessaging(p, proverPhone, k) @ #x))"

end
